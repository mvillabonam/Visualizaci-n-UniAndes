d18 = ifelse(is.finite(densidad_2018) & densidad_2018 > 0, densidad_2018, NA_real_)
)
lims <- range(c(map_dens$d85, map_dens$d18), na.rm = TRUE)
# Si hubo todo NA/Inf o iguales, ajustamos
if (!all(is.finite(lims))) {
# mete un 1 para evitar rango no finito (solo si todo estaba NA)
lims <- range(c(1, map_dens$d85, map_dens$d18), na.rm = TRUE)
}
if (diff(lims) == 0) {        # evita límites idénticos
lims <- lims + c(-0.5, 0.5)
}
# Etiquetador compatible según versión de 'scales'
lab_num <- if (utils::packageVersion("scales") >= "1.2.0") {
scales::label_number(accuracy = 0.1)
} else {
scales::comma_format(accuracy = 1)
}
# Mapas
p85 <- ggplot(map_dens) +
geom_sf(aes(fill = d85), color = NA) +
scale_fill_viridis_c(
option = "magma",
trans = "log10",
limits = lims,                 # <= ojo: con "="
oob = scales::squish,          # valores fuera de rango, los “aprieta”
na.value = "grey90",
labels = lab_num,
name = "Hab/km²"
) +
labs(title = "Densidad poblacional (1985)",
subtitle = "Habitantes por km² (escala log10)") +
theme_minimal(base_size = 12) +
theme(panel.grid = element_blank())
p18 <- ggplot(map_dens) +
geom_sf(aes(fill = d18), color = NA) +
scale_fill_viridis_c(
option = "magma",
trans = "log10",
limits = lims,                 # <= mismo rango para comparar
oob = scales::squish,
na.value = "grey90",
labels = lab_num,
name = "Hab/km²"
) +
labs(title = "Densidad poblacional (2018)",
subtitle = "Habitantes por km² (escala log10)") +
theme_minimal(base_size = 12) +
theme(panel.grid = element_blank())
# Combinar y guardar
p_combo <- p85 + p18 + plot_layout(ncol = 2, guides = "collect") &
theme(legend.position = "right")
p_combo
# 5) Guardar en PNG
ggsave(
filename = "stores/3.3Mapas_densidad_1985_2018_por_departamento.png",
plot = p_combo, width = 14, height = 10, dpi = 300
)
agg_departamento <- pobxarea %>%
filter(ano %in% c(1985, 2018)) %>%
group_by(dp, dpnom, ano) %>%
summarise(
pob_total = sum(poblacion, na.rm = TRUE),
area_total = sum(mpio_narea, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(densidad = pob_total / area_total) %>%
pivot_wider(
names_from = ano,
values_from = c(pob_total, densidad),
names_sep = "_"
) %>%
mutate(
crec_abs = pob_total_2018 - pob_total_1985,
crec_pct = (pob_total_2018 - pob_total_1985) / pob_total_1985 * 100
)
agg_departamento_key <- agg_departamento %>%
mutate(
dp = as.character(dp),
dp = str_extract(dp, "\\d+"),
dp = str_pad(dp, width = 5, pad = "0")
)
col_mpios_key <- col_mpios %>%
mutate(
dpto = as.character(dpto),
dpto = str_extract(dpto, "\\d+"),
dpto = str_pad(dpto, width = 5, pad = "0")
)
# 3) Unir por codmpio (shape) = dppmp (tu data)
# Crear map_dens y límites comunes robustos
map_dens <- map_data %>%
mutate(
d85 = ifelse(is.finite(densidad_1985) & densidad_1985 > 0, densidad_1985, NA_real_),
d18 = ifelse(is.finite(densidad_2018) & densidad_2018 > 0, densidad_2018, NA_real_)
)
lims <- range(c(map_dens$d85, map_dens$d18), na.rm = TRUE)
# --- Limpiar entorno
rm(list = ls())
gc()
closeAllConnections()
# --- Cargar librerías necesarias
library("pacman")
require("pacman")
p_load( tidyverse, data.table, lubridate, readxl, ggthemes, plotly, janitor,
patchwork, ggplot2,openxlsx, writexl,sf,osmdata,dplyr)
# --- Definir rutas
user <- Sys.getenv("USERNAME")
if (user == "judel") {
path <- file.path("C:/Users", "judel", "OneDrive", "Documentos",
"ANDES", "Semestre 3", "Visualizacion de datos", "Actividad 1")
} else if (user == "mvill") {
path <- file.path("C:/Users", "mvill", "OneDrive", "Transitorio", "OneDrive",
"Documentos", "GitHub", "Visualizaci-n-UniAndes")
} else if (user == "hncar") {
path <- file.path("C:/Users", "hncar", "Documents", "GitHub", "Visualizaci-n-UniAndes")
} else {
path <- choose.dir(caption = "Selecciona la carpeta con los archivos")
}
setwd(path)
# --- Cargar datos
file_area      <- file.path(path, "data/mun_area.csv")
file_poblacion <- file.path(path, "data/pob_censal.xlsx")
# Adicional para punto 3
col_mpios <- st_read("data/shapes.shp", quiet = TRUE)
mun_area   <- read_csv(file_area) %>% clean_names()
pob_censal <- read_excel(file_poblacion, sheet = 1) %>% clean_names()
summary(mun_area)
summary(pob_censal)
sapply(mun_area, class)
sapply(pob_censal, class)
# --- pob_censal ---
pob_censal <- pob_censal %>%
mutate(
dpmp = sprintf("%05d", as.integer(dpmp)),   # código municipal 5 dígitos
dp   = sprintf("%02d", as.integer(dp)),     # código depto 2 dígitos
ano = as.integer(ano),
poblacion = as.integer(poblacion),
llave = paste0(dpmp, "_", ano)              # llave única
)
if ("dpnom" %in% names(pob_censal)) {
pob_censal <- pob_censal %>%
mutate(dpnom = tolower(iconv(dpnom, from = "UTF-8", to = "ASCII//TRANSLIT")))
}
# --- mun_area ---
mun_area <- mun_area %>%
rename(ano = ano_creacion) %>%   # renombrar columna
mutate(
dpmp = sprintf("%05d", as.integer(dpmp)),
dp   = sprintf("%02d", as.integer(dp)),
ano  = as.integer(ano),             # ahora ya está como ano
llave = paste0(dpmp, "_", ano)      # misma llave que pob_censal
)
# --- Verificar valores vacíos
cat("\n--- Número de NA's por columna en mun_area ---\n")
sapply(pob_censal, function(x) sum(is.na(x)))
cat("\n--- Número de NA's por columna en pob_censal ---\n")
sapply(mun_area, function(x) sum(is.na(x)))
# --- Verificar duplicados
# --- Población censal ---
duplicados_pob <- pob_censal %>% count(llave) %>% filter(n > 1)
cat("\n>>> Verificación de duplicados en pob_censal <<<\n")
if (nrow(duplicados_pob) > 0) { print(duplicados_pob)} else { cat("No se encontraron duplicados en pob_censal.\n")}
# --- Municipios / áreas ---
duplicados_area <- mun_area %>% count(llave) %>% filter(n > 1)
cat("\n>>> Verificación de duplicados en mun_area <<<\n")
if (nrow(duplicados_area) > 0) { print(duplicados_area)
} else { cat("No se encontraron duplicados en mun_area.\n") }
rm(duplicados_pob, duplicados_area)
# ==========================================================
# Comparación de años
# ==========================================================
anos_pob   <- sort(unique(pob_censal$ano))
anos_area  <- sort(unique(mun_area$ano))
anos_comunes    <- intersect(anos_pob, anos_area)
anos_solo_pob   <- setdiff(anos_pob, anos_area)
anos_solo_area  <- setdiff(anos_area, anos_pob)
cat("\n>>> Comparación de AÑOS <<<\n")
#cat("Años en pob_censal:", anos_pob, "\n")
#cat("Años en mun_area:", anos_area, "\n")
cat("Años en común:", anos_comunes, "\n")
cat("Años SOLO en pob_censal:", anos_solo_pob, "\n")
cat("Años SOLO en mun_area:", anos_solo_area, "\n")
rm(anos_pob,anos_area,anos_comunes,anos_solo_pob,anos_solo_area)
# ==========================================================
# Comparación de municipios (dpmp)
# ==========================================================
dpmp_pob  <- sort(unique(pob_censal$dpmp))
dpmp_area <- sort(unique(mun_area$dpmp))
dpmp_comunes   <- intersect(dpmp_pob, dpmp_area)
dpmp_solo_pob  <- setdiff(dpmp_pob, dpmp_area)
dpmp_solo_area <- setdiff(dpmp_area, dpmp_pob)
cat("\n>>> Comparación de MUNICIPIOS (dpmp) <<<\n")
#cat("Municipios en pob_censal:", length(dpmp_pob), "\n")
#cat("Municipios en mun_area:", length(dpmp_area), "\n")
cat("Municipios en común:", length(dpmp_comunes), "\n")
cat("Municipios SOLO en pob_censal:", length(dpmp_solo_pob), "\n")
cat("Municipios SOLO en mun_area:", length(dpmp_solo_area), "\n")
# Opcional: mostrar ejemplos de los que no coinciden
if (length(dpmp_solo_pob) > 0) {
cat("\nEjemplos de dpmp SOLO en pob_censal:\n")
print(head(dpmp_solo_pob))
}
if (length(dpmp_solo_area) > 0) {
cat("\nEjemplos de dpmp SOLO en mun_area:\n")
print(head(dpmp_solo_area))
}
rm(dpmp_pob,dpmp_area,dpmp_comunes,dpmp_solo_pob,dpmp_solo_area)
# ==========================================================
# Comparación llaves en común
# ==========================================================
llaves_pob   <- sort(unique(pob_censal$llave))
llaves_area  <- sort(unique(mun_area$llave))
llaves_comunes    <- intersect(llaves_pob, llaves_area)
llaves_solo_pob   <- setdiff(llaves_pob, llaves_area)
llave_solo_area  <- setdiff(llaves_area, llaves_pob)
cat("\n>>> Comparación de Llaves (dpmp+año) <<<\n")
cat("Llaves en común:", length(llaves_comunes), "\n")
rm(llaves_pob,llaves_area,llaves_comunes,llaves_solo_pob,llave_solo_area)
# --- población
pob_neg <- pob_censal %>% filter(poblacion < 0 | is.na(poblacion))
if (nrow(pob_neg) > 0) {
cat("⚠ Hay registros con población negativa o NA:\n")
print(pob_neg)
} else {
cat("No hay población negativa.\n")
}
# --- área
if ("area" %in% names(mun_area)) {
area_ceros <- mun_area %>% filter(area <= 0 | is.na(area))
if (nrow(area_ceros) > 0) {
cat("⚠ Hay registros con área <= 0 o NA:\n")
print(area_ceros)
} else {
cat("No hay áreas menores o iguales a 0.\n")
}
# --- tipo de variables (deben coincidir las que son comunes)
sapply(mun_area, class)
sapply(pob_censal, class)
# Departamentos únicos
unique(pob_censal$dpnom)
# Municipios únicos
unique(pob_censal$mpio)
# Estandarizacion de las columna dpnom y mpio
pob_censal$dpnom <- pob_censal$dpnom %>%
str_trim() %>%                                # quitar espacios al inicio/final
str_to_title() %>%                            # pasar a minúsculas
iconv(from = "UTF-8", to = "ASCII//TRANSLIT") # quitar tildes
pob_censal$mpio <- pob_censal$mpio %>%
str_trim() %>%
str_to_title() %>%
iconv(from = "UTF-8", to = "ASCII//TRANSLIT")
pob_censal_ancha <- pob_censal %>%
pivot_wider(
id_cols = c(dp, dpnom, dpmp, mpio),
names_from = ano,
values_from = poblacion,
names_prefix = "Pob_"
)
write.xlsx(pob_censal_ancha,"stores/2.7Poblacion_censal_ancha.xsx")
# Opción 1. Hacer un left-join usando la población poblacional. (Agrega área para 17 municipios)
pobxarea <- pob_censal %>%
left_join(mun_area, by = c("dp", "dpmp","ano","llave"))
summary(pobxarea)
# Opción 2. Hacer un outer-join (full join) pero SOLO utilizando los departamentos y los códigos de los municipios. De forma tal que se impute la misma área para cualquier año. (Asumiendo que no cambia en el tiempo)
full_join_db <- pob_censal %>%
full_join(mun_area, by = c("dp", "dpmp")) %>%
select(-ends_with(".y")) %>%
rename_with(~ sub("\\.x$", "", .x), ends_with(".x"))
summary(full_join_db)
faltantes_en_pob_censal <- pob_censal %>%
anti_join(mun_area, by = c("dp", "dpmp"))
faltantes_en_area <- mun_area %>%
anti_join(pob_censal, by = c("dp", "dpmp"))
faltantes_en_pob_censal
pobxarea <- full_join_db %>%
mutate(densidad = poblacion / mpio_narea)
pobxarea
write_xlsx(pobxarea,"stores/3.1 DensidadPoblacional.xlsx")
# 2) Normalizar llaves (5 dígitos) en ambas tablas: pobxarea$dppmp y col_mpios$codmpio
pobxarea_key <- pobxarea %>%
mutate(
dpmp = as.character(dpmp),
dpmp = str_extract(dpmp, "\\d+"),
dpmp = str_pad(dpmp, width = 5, pad = "0")
)
col_mpios_key <- col_mpios %>%
mutate(
codmpio = as.character(mpios),
codmpio = str_extract(mpios, "\\d+"),
codmpio = str_pad(mpios, width = 5, pad = "0")
)
# 3) Unir por codmpio (shape) = dppmp (tu data)
map_data <- col_mpios_key %>%
left_join(
pobxarea_key %>% select(dpmp, densidad),
by = c("codmpio" = "dpmp")
)
# 4) Mapa
ggplot(map_data) +
geom_sf(aes(fill = densidad), color = NA) +
scale_fill_viridis_c(
option = "magma",
trans = "log10",
na.value = "grey90",
labels = scales::label_number(accuracy = 0.1)
) +
labs(
title = "Densidad poblacional promedio por municipio en Colombia",
subtitle = "Habitantes por km² (escala log10)",
fill = "Hab/km²"
) +
theme_minimal(base_size = 12) +
theme(panel.grid = element_blank())
ggsave(
filename = "stores/3.1mapa_densidad_promedio_colombia.png", # ruta y nombre del archivo
plot = last_plot(),   # guarda el último gráfico generado
width = 10,           # ancho en pulgadas
height = 12,          # alto en pulgadas
dpi = 300             # resolución (buena calidad para informes)
)
pob_2 <- pobxarea %>%
filter(ano %in% c(1985, 2018)) %>%
select(dp, dpnom, dpmp, mpio, ano, poblacion) %>%
pivot_wider(
names_from = ano,
values_from = poblacion,
names_prefix = "Pob_"
) %>%
mutate(
crec_absoluto = Pob_2018 - Pob_1985,
crec_porcentual = (Pob_2018 - Pob_1985) / Pob_1985 * 100
)
print(pob_2)
write_xlsx(pob_2,"stores/3.2 Crecimiento absoluto y porcentual1985-2018.xlsx")
# 2) Normalizar llaves (5 dígitos) en ambas tablas: pob_2$dppmp y col_mpios$codmpio
pob_2_key <- pob_2 %>%
mutate(
dpmp = as.character(dpmp),
dpmp = str_extract(dpmp, "\\d+"),
dpmp = str_pad(dpmp, width = 5, pad = "0")
)
col_mpios_key <- col_mpios %>%
mutate(
codmpio = as.character(mpios),
codmpio = str_extract(mpios, "\\d+"),
codmpio = str_pad(mpios, width = 5, pad = "0")
)
# 3) Unir por codmpio (shape) = dppmp (tu data)
map_data <- col_mpios_key %>%
left_join(
pob_2_key %>% select(dpmp, crec_absoluto, crec_porcentual),
by = c("codmpio" = "dpmp")
) %>%
mutate(
# Evitar infinitos/NaN cuando Pob_1985 = 0
crec_porcentual = ifelse(is.infinite(crec_porcentual) | is.nan(crec_porcentual), NA, crec_porcentual)
)
# 4) Mapa crecimiento absoluto
ggplot(map_data) +
geom_sf(aes(fill = crec_absoluto), color = NA) +
scale_fill_viridis_c(
option = "magma",
trans = "log10",
na.value = "grey90",
labels = scales::label_number(accuracy = 0.1)
) +
labs(
title = "Crecimiento absoluto municipio en Colombia",
subtitle = "(escala log10)",
) +
theme_minimal(base_size = 12) +
theme(panel.grid = element_blank())
# --- Guardar en PNG -------------------------------------------------
ggsave(
filename = "stores/mapas_crecimiento_absoluto_1985_2018.png",
plot = last_plot(), width = 14, height = 10, dpi = 300
)
# 5) Mapa crecimiento porcentual
lab_pct <- scales::percent_format(accuracy = 0.1, scale = 1)
ggplot(map_data) +
geom_sf(aes(fill = crec_porcentual), color = NA) +
scale_fill_gradient2(
low = "#2C7BB6", mid = "grey95", high = "#D7191C",
midpoint = 0,
na.value = "grey85",
labels = lab_pct,
name = "Crec. %"
) +
labs(
title = "Crecimiento porcentual por municipio en Colombia",
subtitle = "Variación 2018 vs 1985",
caption = "Nota: municipios con población 1985=0 se muestran como NA"
) +
theme_minimal(base_size = 12) +
theme(panel.grid = element_blank())
# --- Guardar en PNG -------------------------------------------------
ggsave(
"stores/mapa_crecimiento_porcentual_1985_2018.png",
plot = last_plot(), width = 10, height = 12, dpi = 300
)
agg_departamento <- pobxarea %>%
filter(ano %in% c(1985, 2018)) %>%
group_by(dp, dpnom, ano) %>%
summarise(
pob_total = sum(poblacion, na.rm = TRUE),
area_total = sum(mpio_narea, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(densidad = pob_total / area_total) %>%
pivot_wider(
names_from = ano,
values_from = c(pob_total, densidad),
names_sep = "_"
) %>%
mutate(
crec_abs = pob_total_2018 - pob_total_1985,
crec_pct = (pob_total_2018 - pob_total_1985) / pob_total_1985 * 100
)
agg_departamento_key <- agg_departamento %>%
mutate(
dp = as.character(dp),
dp = str_extract(dp, "\\d+"),
dp = str_pad(dp, width = 5, pad = "0")
)
col_mpios_key <- col_mpios %>%
mutate(
dpto = as.character(dpto),
dpto = str_extract(dpto, "\\d+"),
dpto = str_pad(dpto, width = 5, pad = "0")
)
# 3) Unir por codmpio (shape) = dppmp (tu data)
# Crear map_dens y límites comunes robustos
map_dens <- map_data %>%
mutate(
d85 = ifelse(is.finite(densidad_1985) & densidad_1985 > 0, densidad_1985, NA_real_),
d18 = ifelse(is.finite(densidad_2018) & densidad_2018 > 0, densidad_2018, NA_real_)
)
agg_departamento_key <- agg_departamento %>%
mutate(
dp = as.character(dp),
dp = str_extract(dp, "\\d+"),
dp = str_pad(dp, width = 5, pad = "0")
)
col_mpios_key <- col_mpios %>%
mutate(
dpto = as.character(dpto),
dpto = str_extract(dpto, "\\d+"),
dpto = str_pad(dpto, width = 5, pad = "0")
)
# 3) Unir por codmpio (shape) = dppmp (tu data)
map_data <- col_mpios_key %>%
left_join( agg_departamento_key %>%
select(dp, densidad_1985,densidad_2018,crec_abs,crec_pct), by = c("dpto" = "dp"))
%>% mutate( Pob_1985 = 0 crec_pct = ifelse(is.infinite(crec_pct) | is.nan(crec_pct), NA, crec_pct) )
# Crear map_dens y límites comunes robustos
map_dens <- map_data %>%
mutate(
d85 = ifelse(is.finite(densidad_1985) & densidad_1985 > 0, densidad_1985, NA_real_),
d18 = ifelse(is.finite(densidad_2018) & densidad_2018 > 0, densidad_2018, NA_real_)
)
lims <- range(c(map_dens$d85, map_dens$d18), na.rm = TRUE)
# Si hubo todo NA/Inf o iguales, ajustamos
if (!all(is.finite(lims))) {
# mete un 1 para evitar rango no finito (solo si todo estaba NA)
lims <- range(c(1, map_dens$d85, map_dens$d18), na.rm = TRUE)
}
if (diff(lims) == 0) {        # evita límites idénticos
lims <- lims + c(-0.5, 0.5)
}
# Etiquetador compatible según versión de 'scales'
lab_num <- if (utils::packageVersion("scales") >= "1.2.0") {
scales::label_number(accuracy = 0.1)
} else {
scales::comma_format(accuracy = 1)
}
# Mapas
p85 <- ggplot(map_dens) +
geom_sf(aes(fill = d85), color = NA) +
scale_fill_viridis_c(
option = "magma",
trans = "log10",
limits = lims,                 # <= ojo: con "="
oob = scales::squish,          # valores fuera de rango, los “aprieta”
na.value = "grey90",
labels = lab_num,
name = "Hab/km²"
) +
labs(title = "Densidad poblacional (1985)",
subtitle = "Habitantes por km² (escala log10)") +
theme_minimal(base_size = 12) +
theme(panel.grid = element_blank())
p18 <- ggplot(map_dens) +
geom_sf(aes(fill = d18), color = NA) +
scale_fill_viridis_c(
option = "magma",
trans = "log10",
limits = lims,                 # <= mismo rango para comparar
oob = scales::squish,
na.value = "grey90",
labels = lab_num,
name = "Hab/km²"
) +
labs(title = "Densidad poblacional (2018)",
subtitle = "Habitantes por km² (escala log10)") +
theme_minimal(base_size = 12) +
theme(panel.grid = element_blank())
# Combinar y guardar
if (!requireNamespace("patchwork", quietly = TRUE)) install.packages("patchwork")
library(patchwork)
p_combo <- p85 + p18 + plot_layout(ncol = 2, guides = "collect") &
theme(legend.position = "right")
p_combo
ggsave("stores/mapas_densidad_1985_2018.png", p_combo, width = 14, height = 10, dpi = 300)
