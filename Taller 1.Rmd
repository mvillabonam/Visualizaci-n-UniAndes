---
title: "Taller 1 - Visualización y Exploración de bases de datos"
author: " Henry Carvajal (201718787),Julian Delgado () , Mariana Villabona (201816559)"
date: "Visualización y Exploración de datos para ciencias sociales"
output: html_document
---

```{r Setup, include=FALSE}
# --- Limpiar entorno
rm(list = ls())
gc()
closeAllConnections()

# --- Cargar librerías necesarias
library("pacman")
require("pacman")
p_load( tidyverse, data.table, lubridate, readxl, ggthemes, plotly, janitor,ggplot2)

# --- Definir rutas
user <- Sys.getenv("USERNAME")

if (user == "judel") {
  path <- file.path("C:/Users", "judel", "OneDrive", "Documentos", 
                    "ANDES", "Semestre 3", "Visualizacion de datos", "Actividad 1")
} else if (user == "mvill") {
  path <- file.path("C:/Users", "mvill", "OneDrive", "Transitorio", "OneDrive", 
                    "Documentos", "GitHub", "Visualizaci-n-UniAndes")
} else if (user == "hncar") {
  path <- file.path("C:/Users", "hncar", "Documents", "GitHub", "Visualizaci-n-UniAndes")
} else {
  path <- choose.dir(caption = "Selecciona la carpeta con los archivos")
}

setwd(path)

# --- Cargar datos 
file_area      <- file.path(path, "data/mun_area.csv")
file_poblacion <- file.path(path, "data/pob_censal.xlsx")

mun_area   <- read_csv(file_area) %>% clean_names()
pob_censal <- read_excel(file_poblacion, sheet = 1) %>% clean_names()
```

## Entendimiento de los datos

1. Identifique y justifique la *unidad de observación* en cada tabla de datos 
suministrados

- **mun_area**: 
  Este archivo es un documento en formato csv que permite guardar información en un  texto plano, 
  donde los datos se guardan en filas y columnas separadas por comas u otro separador. Este 
  formato permite guardar una gran cantidad de información ocupando menos espacio que un excel regular, 
  además de ser compatible por muchos otros tipos de programa para lograr leerlos. Con respecto a los datos
  que contiene, cada fila describe para un municipio en Colombia, identificado por la llave única dpmp.
  Este identificador corresponde al codigo DIVIPOLA, que es el sistema de codificacion de la division 
  politica - administrativa de los departamentos y municipios en el territorio nacional, creado por el DANE.
  Además, presenta información sobre su área, el departamento al que pertenece, el año en que fue creado. 

- **pob_censal**: 
  A diferencia del archivo anterior, este es un archivo xlsx que correponde al formato regular de los archivos excel.
  Este permite observar los datos desde una hoja de datos, facilitando su visualizacion y manejo, aunque implicando un
  mayor peso de almacenamiento Cada fila describe para un municipio en Colombia, identificado por la llave única dpmp.
  Esta llave tambien corresponde al codigo unico DIVIPOLA, por lo que desde este punto es importante asegurar que esta
  columna este correctaente leida y con un formato correcto para poder realizar el cruce con la tabla mun-area.
  Además, la tabla tambien presenta información sobre la población de dicho municipio, el departamento al que 
  pertenece y su nombre; así cómo el año al que pertenece la información de población.

```{r Resumen}
summary(mun_area)
summary(pob_censal)
```

2. Clasifique cada variable como identificación o medición; indique tipo y 
formato.

| Municipios                          | Población                           |
|-------------------------------------|-------------------------------------|
| ![](stores/2.mun_area.png){width=300px} | ![](stores/2.pob_censal.png){width=350px} |

- **mun_area**: dp, dpmp  son tipo carácter mientras que mpio_narea y ano_creación tipo numérico (64 bits).}
  Asi mismo, dp, dpmp y ano_creación son variables de identificación que guardan características especificas del 
  municipio que representan y nos ayudan a diferenciarlas de los otros registros. Por otro lado, mpio_narea es una
  variable de medición que permite comparar el área del municipio con respecto al de los demás y nos permite
  clasificar los municipios por su tamaño o encontrar territorios con áreas similares.
- **pob_censal**: dpnom, mpio  son tipo caracter mientras que dp, población, dpmp, ano son tipo numérico (64 bits). 
  De forma similar a la tabla anterior, todas las variables con excepcion de "poblacion" son de tipo identificación
  que diferencian cada registro entre si, mientras que población hace referencia a una variable numérica de medición
  la cual nos dice cual es el número de habitantes de cada municipio en un año determinado, permitiendo analizar su   
  distribución demográfica, comparar densidades poblacionales y estudiar la evolución de la población en el tiempo.

```{r Tipo y formato}
sapply(mun_area, class)
sapply(pob_censal, class)
```

3. Proponga al menos 3 reglas mínimas de consistencia para asegurar la calidad de 
los datos de las variables disponibles y que constituyen parte de la documentación 
del ejercicio.

- **Regla 1**: La variable dp debe ser igual para cualquier municipio entre las bases de datos. 
  (Asumiendo que los municipios no se relocalizan sobre otros departamentos).
- **Regla 2**: La población debe ser mayor a cero para el año en que se reporta.
- **Regla 3**: El área de un municipio debe siempre ser mayor a cero.
- **Regla 4**: Las ciudades capitales deben concentrar más población en cada departamento. 
- **Regla 5**: Los años con censo son: 1985,1993,2005 o 2018.


## Preparación de los datos 

1. Construya la llave única para la tabla de población (sugerencia: DPMP + AÑO).

```{r 1. Preparación de datos y creación de llaves}
# --- pob_censal ---
pob_censal <- pob_censal %>%
  mutate(
    dpmp = sprintf("%05d", as.integer(dpmp)),   # código municipal 5 dígitos
    dp   = sprintf("%02d", as.integer(dp)),     # código depto 2 dígitos
    ano = as.integer(ano),
    poblacion = as.integer(poblacion),
    llave = paste0(dpmp, "_", ano)              # llave única
  )

if ("dpnom" %in% names(pob_censal)) {
  pob_censal <- pob_censal %>%
    mutate(dpnom = tolower(iconv(dpnom, from = "UTF-8", to = "ASCII//TRANSLIT")))
}

# --- mun_area ---
mun_area <- mun_area %>%
  rename(ano = ano_creacion) %>%   # renombrar columna
  mutate(
    dpmp = sprintf("%05d", as.integer(dpmp)),
    dp   = sprintf("%02d", as.integer(dp)),
    ano  = as.integer(ano),             # ahora ya está como ano
    llave = paste0(dpmp, "_", ano)      # misma llave que pob_censal
  )
```

2. Verifique duplicados; reporte conteos y la decisión de tratamiento. 
- **Respuesta**: Dado que no se presentan duplicados o valores vacíos, no se aplica tratamiento.

```{r 2. Duplicados y vacíos}
# --- Verificar valores vacíos
cat("\n--- Número de NA's por columna en mun_area ---\n")
sapply(pob_censal, function(x) sum(is.na(x)))
cat("\n--- Número de NA's por columna en pob_censal ---\n")
sapply(mun_area, function(x) sum(is.na(x)))

# --- Verificar duplicados

# --- Población censal ---
duplicados_pob <- pob_censal %>% count(llave) %>% filter(n > 1)

cat("\n>>> Verificación de duplicados en pob_censal <<<\n")
if (nrow(duplicados_pob) > 0) { print(duplicados_pob)} else { cat("No se encontraron duplicados en pob_censal.\n")}

# --- Municipios / áreas ---
duplicados_area <- mun_area %>% count(llave) %>% filter(n > 1)

cat("\n>>> Verificación de duplicados en mun_area <<<\n")
if (nrow(duplicados_area) > 0) { print(duplicados_area)
} else { cat("No se encontraron duplicados en mun_area.\n") }

rm(duplicados_pob, duplicados_area)
```

3. Explique qué tipo de unión tendrían las tablas disponibles y por qué.

- **Respuesta**: Si no quisiéramos perder nada de información 
  debería realizarse un outer join usando la llave creada anteriormente. El outer join es la manera en la
  que preservamos más información sobre los municipios en cada año dado que este tipo de union busca mantener 
  todos los datos de ambas tablas a relacionar, sin darle importancia a que la llave buscada se encuentre en 
  ambas tablas.
  
  En nuestro caso, dado que las bases de datos solo comparten los años 1985 y 1993; pero comparten casi todos los       
  municipios (exceptuando el 94663 solo disponible en población censal) podemos tener una base de datos única que 
  contemple toda la información disponible en pob_censal y se complemente con información relacionada al área del
  municipio para los años disponibles. 
  
  Sin embargo, considerando que solo comparten 17 observaciones (Municipios y años comunes)
  podría ser de interés solo preservar la data de población censal y agregar, para los años 
  disponibles, el área de los 17 municipios en común. Lo anterior puede realizarse con un 
  left join o right join, dependiendo de cual tabla queramos mantener como la "principal" o la
  tabla maestra.
  
  Además, procuramos preservar el formato long dado que este formato favorece la manipulación
  de la información para el análisis descriptivo. 

```{r 3. Análisis unión, echo=FALSE, message=FALSE}
# ==========================================================
# Comparación de años
# ==========================================================
anos_pob   <- sort(unique(pob_censal$ano))
anos_area  <- sort(unique(mun_area$ano))

anos_comunes    <- intersect(anos_pob, anos_area)
anos_solo_pob   <- setdiff(anos_pob, anos_area)
anos_solo_area  <- setdiff(anos_area, anos_pob)

cat("\n>>> Comparación de AÑOS <<<\n")
#cat("Años en pob_censal:", anos_pob, "\n")
#cat("Años en mun_area:", anos_area, "\n")
cat("Años en común:", anos_comunes, "\n")
cat("Años SOLO en pob_censal:", anos_solo_pob, "\n")
cat("Años SOLO en mun_area:", anos_solo_area, "\n")

rm(anos_pob,anos_area,anos_comunes,anos_solo_pob,anos_solo_area)

# ==========================================================
# Comparación de municipios (dpmp)
# ==========================================================
dpmp_pob  <- sort(unique(pob_censal$dpmp))
dpmp_area <- sort(unique(mun_area$dpmp))

dpmp_comunes   <- intersect(dpmp_pob, dpmp_area)
dpmp_solo_pob  <- setdiff(dpmp_pob, dpmp_area)
dpmp_solo_area <- setdiff(dpmp_area, dpmp_pob)

cat("\n>>> Comparación de MUNICIPIOS (dpmp) <<<\n")
#cat("Municipios en pob_censal:", length(dpmp_pob), "\n")
#cat("Municipios en mun_area:", length(dpmp_area), "\n")
cat("Municipios en común:", length(dpmp_comunes), "\n")
cat("Municipios SOLO en pob_censal:", length(dpmp_solo_pob), "\n")
cat("Municipios SOLO en mun_area:", length(dpmp_solo_area), "\n")

# Opcional: mostrar ejemplos de los que no coinciden
if (length(dpmp_solo_pob) > 0) {
  cat("\nEjemplos de dpmp SOLO en pob_censal:\n")
  print(head(dpmp_solo_pob))
}
if (length(dpmp_solo_area) > 0) {
  cat("\nEjemplos de dpmp SOLO en mun_area:\n")
  print(head(dpmp_solo_area))
}

rm(dpmp_pob,dpmp_area,dpmp_comunes,dpmp_solo_pob,dpmp_solo_area)

# ==========================================================
# Comparación llaves en común
# ==========================================================
llaves_pob   <- sort(unique(pob_censal$llave))
llaves_area  <- sort(unique(mun_area$llave))

llaves_comunes    <- intersect(llaves_pob, llaves_area)
llaves_solo_pob   <- setdiff(llaves_pob, llaves_area)
llave_solo_area  <- setdiff(llaves_area, llaves_pob)

cat("\n>>> Comparación de Llaves (dpmp+año) <<<\n")
cat("Llaves en común:", length(llaves_comunes), "\n")

rm(llaves_pob,llaves_area,llaves_comunes,llaves_solo_pob,llave_solo_area)
```

4. Asegure tipos de datos correctos de acuerdo con las reglas que identificó previamente ( e.g.
DP, DPMP caracteres que pueden iniciar con “0”; Población entera).


```{r Checks por variable, echo=FALSE, message=FALSE}
# --- población
pob_neg <- pob_censal %>% filter(poblacion < 0 | is.na(poblacion))
if (nrow(pob_neg) > 0) { cat("⚠ Hay registros con población negativa o NA:\n") print(pob_neg)
} else { cat("No hay población negativa.\n") }

# --- área
if ("area" %in% names(mun_area)) {
  area_ceros <- mun_area %>% filter(area <= 0 | is.na(area))
  if (nrow(area_ceros) > 0) { cat("⚠ Hay registros con área <= 0 o NA:\n")
    print(area_ceros) } else { cat("No hay áreas menores o iguales a 0.\n")}}

# --- tipo de variables (deben coincidir las que son comunes)
sapply(mun_area, class)
sapply(pob_censal, class)

# --- Estandarización


```


6. Estandarice nombres (mayúsculas/acentos) en DPNOM y MPIO, si es necesario.


```{r Estandarizacion}
# Departamentos únicos
unique(pob_censal$dpnom)

# Municipios únicos
unique(pob_censal$mpio)

# Estandarizacion de las columna dpnom y mpio
pob_censal$dpnom <- pob_censal$dpnom %>%
  str_trim() %>%                                # quitar espacios al inicio/final
  str_to_lower() %>%                            # pasar a minúsculas
  iconv(from = "UTF-8", to = "ASCII//TRANSLIT") # quitar tildes

pob_censal$mpio <- pob_censal$mpio %>%
  str_trim() %>%
  str_to_lower() %>%
  iconv(from = "UTF-8", to = "ASCII//TRANSLIT")


```


7. A par@r de la estructura larga de la tabla población (AÑO en columna), cree una versión
ancha con columnas Pob_1985, Pob_1993, Pob_2005, Pob_2018 y guárdela en un nuevo
archivo.


```{r Tabla ancha}

pob_censal_ancha <- pob_censal %>%
  pivot_wider(
    id_cols = c(dp, dpnom, dpmp, mpio),     
    names_from = ano,                        
    values_from = poblacion,                 
    names_prefix = "Pob_"                    
  )

```

8. Explique cuándo trabajar en largo vs. en ancho para las operaciones siguientes.

La decisión de trabajar los datos en formato largo (long) o ancho (wide) depende del tipo de operación que se quiera ejecutar.
Al realizar una unión con otra tabla no habría mayor diferencia entre usar uno u otro formato, ya que las columnas que se expanden en el formato ancho (en este caso la población) no intervienen en el cruce de las tablas.
No obstante, para fines de visualización, el formato ancho permite una comparación rápida de los valores entre diferentes años dentro de un mismo municipio o entre municipios distintos.

Por otro lado, al realizar cálculos que requieren relacionar una variable con otra (por ejemplo, población respecto al área), el formato largo suele ser más recomendable, ya que permite trabajar con todos los valores de población independientemente del año en una sola columna. En cambio, en el formato ancho sería necesario tomar cada valor de población por año y repetir la operación para cada columna.

Sin embargo, cuando se trata de comparar valores entre años específicos, como el cálculo del crecimiento poblacional entre dos censos, el formato ancho puede resultar más beneficioso, ya que basta con operar directamente entre las columnas correspondientes a cada año. En formato largo, este tipo de comparación requeriría más pasos intermedios o incluso generar una tabla auxiliar donde se almacenen los resultados.



## Integración de tablas (join), validaciones y cálculos

1. Realice la unión de las tablas población (largo) con mun_area.csv


```{r cruce de los datos}
  
pobxarea <- pob_censal %>%
  left_join(mun_area, by = c("dp", "dpmp"))


```

