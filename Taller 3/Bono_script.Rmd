---
title: "Actividad 3"
subtitle: "Facultad de Economía, Universidad de los Andes"
author: "Henry Carvajal (201718787),Julian Delgado (201712798) , Mariana Villabona (201816559)"
date: "2025-10-15"
output: html_document
---

#Ambiente

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Preparación del entorno -------------------------------------------
rm(list = ls())              # Limpiar memoria de objetos
gc()                         # Liberar memoria no usada
closeAllConnections()        # Cerrar conexiones abiertas

# Cargar librerías -------------------------------------------------
library(pacman)
p_load(
  tidyverse, data.table, lubridate, readxl, ggthemes, plotly,
  janitor, openxlsx, writexl, stringi, patchwork, skimr,
  sf, osmdata, boot, ggplot2
)

# Definir carpeta de datos (ruta relativa) ------------------------
user <- Sys.getenv("USERNAME")

if (user == "judel") {
  path <- file.path("C:/Users", "judel", "OneDrive", "Documentos", 
                    "ANDES", "Semestre 3", "Visualizacion de datos", "Bono")
} else if (user == "mvill") {
  path <- file.path("C:/Users", "mvill", "OneDrive", "Transitorio", "OneDrive", 
                    "Documentos", "GitHub", "Visualizaci-n-UniAndes","Taller 2")
} else if (user == "hncar") {
  path <- file.path("C:/Users", "hncar", "Documents", "GitHub", "Visualizaci-n-UniAndes", "Taller 3", "data")
} else {
  path <- choose.dir(caption = "Selecciona la carpeta con los archivos")
}

setwd(path)
cat("Directorio de trabajo:", path, "\n")

# Crear carpeta de figuras si no existe
dir.create(file.path(getwd(),"figuras"), recursive = TRUE, showWarnings = FALSE)

# Ruta de salida
fig_path <- file.path(getwd(),"figuras")


```

#Limpieza y resumen inicial

```{r}
# ============================================================
# Importar y preparar datos de PIB y CO₂
# ============================================================

pib_file <- file.path(path, "PIB.xls")
co2_file <- file.path(path, "CO2.xls")

data_pib <- read_excel(pib_file, sheet = "Data", skip = 3) %>% clean_names()
data_co2 <- read_excel(co2_file, sheet = "Data", skip = 3) %>% clean_names()

cat("\nColumnas en data_pib:\n")
print(colnames(data_pib))
cat("\nColumnas en data_co2:\n")
print(colnames(data_co2))
cat("\nDatos disponibles desde 1960 hasta 2024\n")

# ============================================================
# Transformar a formato long y limitar a 2003–2023
# ============================================================

pib_long <- data_pib %>%
  pivot_longer(cols = starts_with("x"), names_to = "anio", values_to = "valor_pib") %>%
  mutate(anio = as.numeric(gsub("x", "", anio))) %>%
  filter(anio >= 2003, anio <= 2023)

co2_long <- data_co2 %>%
  pivot_longer(cols = starts_with("x"), names_to = "anio", values_to = "valor_co2") %>%
  mutate(anio = as.numeric(gsub("x", "", anio))) %>%
  filter(anio >= 2003, anio <= 2023)

# ============================================================
# Limpieza de NAs y outliers por año (criterio IQR)
# ============================================================

# Filtrar valores válidos y positivos
pib_long <- pib_long %>%
  filter(!is.na(valor_pib), valor_pib > 0)
co2_long <- co2_long %>%
  filter(!is.na(valor_co2), valor_co2 > 0)

# Función para eliminar outliers dentro de cada año
remove_outliers_by_year <- function(df, value_col){
  df %>%
    group_by(anio) %>%
    mutate(
      q1 = quantile(.data[[value_col]], 0.25, na.rm = TRUE),
      q3 = quantile(.data[[value_col]], 0.75, na.rm = TRUE),
      iqr = q3 - q1,
      lower = q1 - 1.5 * iqr,
      upper = q3 + 1.5 * iqr
    ) %>%
    ungroup() %>%
    filter(.data[[value_col]] >= lower, .data[[value_col]] <= upper) %>%
    select(-q1, -q3, -iqr, -lower, -upper)
}

# Aplicar la limpieza anual
pib_long <- remove_outliers_by_year(pib_long, "valor_pib")
co2_long <- remove_outliers_by_year(co2_long, "valor_co2")

# Mostrar conteo final
cat("PIB observaciones finales:", nrow(pib_long), "\n")
cat("CO₂ observaciones finales:", nrow(co2_long), "\n")

# ============================================================
# Estadísticas descriptivas globales
# ============================================================

summary_pib <- pib_long %>%
  summarise(
    promedio = mean(valor_pib, na.rm = TRUE),
    mediana = median(valor_pib, na.rm = TRUE),
    desviacion = sd(valor_pib, na.rm = TRUE),
    minimo = min(valor_pib, na.rm = TRUE),
    maximo = max(valor_pib, na.rm = TRUE),
    observaciones = sum(!is.na(valor_pib))
  )

summary_co2 <- co2_long %>%
  summarise(
    promedio = mean(valor_co2, na.rm = TRUE),
    mediana = median(valor_co2, na.rm = TRUE),
    desviacion = sd(valor_co2, na.rm = TRUE),
    minimo = min(valor_co2, na.rm = TRUE),
    maximo = max(valor_co2, na.rm = TRUE),
    observaciones = sum(!is.na(valor_co2))
  )

# ============================================================
# Identificar valores extremos dentro del rango limpio
# ============================================================

pib_min <- pib_long %>%
  filter(valor_pib == min(valor_pib, na.rm = TRUE)) %>%
  select(country_name, anio, valor_pib)

pib_max <- pib_long %>%
  filter(valor_pib == max(valor_pib, na.rm = TRUE)) %>%
  select(country_name, anio, valor_pib)

co2_min <- co2_long %>%
  filter(valor_co2 == min(valor_co2, na.rm = TRUE)) %>%
  select(country_name, anio, valor_co2)

co2_max <- co2_long %>%
  filter(valor_co2 == max(valor_co2, na.rm = TRUE)) %>%
  select(country_name, anio, valor_co2)

# ============================================================
# Promedio global por año (2003–2023)
# ============================================================

pib_anual <- pib_long %>%
  group_by(anio) %>%
  summarise(promedio_pib = mean(valor_pib, na.rm = TRUE))

co2_anual <- co2_long %>%
  group_by(anio) %>%
  summarise(promedio_co2 = mean(valor_co2, na.rm = TRUE))

# ============================================================
# Gráficos de tendencia global
# ============================================================

plot_pib <- ggplot(pib_anual, aes(x = anio, y = promedio_pib)) +
  geom_line(color = "#E41A1C", size = 1, na.rm = TRUE) +
  geom_point(color = "#E41A1C", na.rm = TRUE) +
  labs(
    title = "Promedio del PIB per cápita (2003–2023)",
    x = "Año",
    y = "PIB per cápita (US$)"
  ) +
  theme_minimal()

plot_co2 <- ggplot(co2_anual, aes(x = anio, y = promedio_co2)) +
  geom_line(color = "#4DAF4A", size = 1, na.rm = TRUE) +
  geom_point(color = "#4DAF4A", na.rm = TRUE) +
  labs(
    title = "Promedio de emisiones de CO2 per cápita (2003–2023)",
    x = "Año",
    y = "Emisiones per cápita (toneladas)"
  ) +
  theme_minimal()

pib_vs_co2 <- plot_pib + plot_co2
pib_vs_co2

ggsave(
  filename = file.path(fig_path, "Primera_comparacion_pib_co2.png"),
  plot = pib_vs_co2, width = 16, height = 6, dpi = 300
)


```


```{r}

# ============================================================
# Comparación de países con mayor y menor PIB promedio
# ============================================================

pib_promedio_pais <- pib_long %>%
  group_by(country_name) %>%
  summarise(promedio_pib = mean(valor_pib, na.rm = TRUE)) %>%
  filter(!is.na(promedio_pib)) %>%
  arrange(desc(promedio_pib))

paises_mayor_pib <- pib_promedio_pais %>%
  slice_head(n = 3) %>%
  pull(country_name)

paises_menor_pib <- pib_promedio_pais %>%
  slice_tail(n = 3) %>%
  pull(country_name)

co2_filtrado <- co2_long %>%
  filter(country_name %in% c(paises_mayor_pib, paises_menor_pib)) %>%
  mutate(grupo_pib = case_when(
    country_name %in% paises_mayor_pib ~ "Mayor PIB promedio",
    country_name %in% paises_menor_pib ~ "Menor PIB promedio"
  ))

comparacion_emisiones <- ggplot(co2_filtrado, aes(x = anio, y = valor_co2, color = country_name)) +
  geom_line(size = 1.2, na.rm = TRUE) +
  geom_point(size = 1.8, na.rm = TRUE) +
  labs(
    title = "Evolución de las emisiones per cápita (2003–2023)",
    subtitle = "Países con el 3 mayor y 3 menor PIB promedio",
    x = "Año",
    y = "Emisiones per cápita (toneladas)",
    color = "País"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold"),
    legend.position = "bottom"
  )

comparacion_emisiones

ggsave(
  filename = file.path(fig_path, "Evolucion_de_las_emisiones.png"),
  plot = comparacion_emisiones, width = 8, height = 6, dpi = 300
)

```

```{r}


# Seleccionar columnas de interés para 2023 ---------------------
pib_2023 <- data_pib %>%
  select(country_code, pib_2023 = x2023)

co2_2023 <- data_co2 %>%
  select(country_code, co2_2023 = x2023)

# Integrar datasets por código de país -------------------------
data_join <- left_join(pib_2023, co2_2023, by = "country_code") %>%
  drop_na()

# Clasificación: Alto vs. Bajo PIB -----------------------------
data_join <- data_join %>%
  mutate(grupo_pib = if_else(
    pib_2023 >= median(pib_2023, na.rm = TRUE),
    "Alto PIB per cápita",
    "Bajo PIB per cápita"
  ))

# Resumen descriptivo      ----------------------------------
resumen <- data_join %>%
  group_by(grupo_pib) %>%
  summarise(promedio_co2 = mean(co2_2023, na.rm = TRUE))

print(resumen)

# Separando los DF --------------------------------------------
d1 <- data_join %>% filter(grupo_pib=="Alto PIB per cápita")
d2 <- data_join %>% filter(grupo_pib=="Bajo PIB per cápita")

```

# Calculando los IC 95%

```{r}
# ============================================================
# Paso 1. Función de media para bootstrap
# ============================================================
boot_mean <- function(data, indices) {
  d <- data[indices, ]              
  mean(d$co2_2023)                  # ya no verificamos NA
}

# ============================================================
# Paso 2. Función que devuelve media y ambos IC95% (BCa y Percentil)
# ============================================================
summarize_boot_both <- function(df, etiqueta, R = 10000, seed = 123){
  set.seed(seed)
  b  <- boot::boot(df, statistic = boot_mean, R = R)
  ci <- boot::boot.ci(b, type = c("bca", "perc"))
  
  # Extraer ambos IC (si alguno no se puede calcular, queda NA)
  lwr_bca <- if (!is.null(ci$bca))    ci$bca[4]    else NA_real_
  upr_bca <- if (!is.null(ci$bca))    ci$bca[5]    else NA_real_
  lwr_per <- if (!is.null(ci$percent)) ci$percent[4] else NA_real_
  upr_per <- if (!is.null(ci$percent)) ci$percent[5] else NA_real_
  
  tibble::tibble(
    grupo_pib      = etiqueta,
    n_paises       = nrow(df),
    mean_co2       = mean(df$co2_2023),
    boot_R         = R,
    ic95_low_bca   = lwr_bca,
    ic95_high_bca  = upr_bca,
    ic95_low_perc  = lwr_per,
    ic95_high_perc = upr_per
  )
}

# ============================================================
# Paso 3. Aplicar a cada grupo (Alto / Bajo PIB) y redondear
# ============================================================
tabla_ic_wide <- dplyr::bind_rows(
  summarize_boot_both(d1, "Alto PIB per cápita"),
  summarize_boot_both(d2, "Bajo PIB per cápita")
) %>%
  dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ round(.x, 3)))

print(tabla_ic_wide)

```


La tabla presenta los resultados del análisis bootstrap de la media de emisiones de CO₂ per cápita en 2023, comparando países de alto y bajo PIB per cápita. Para los países con alto PIB per cápita (n = 120), la media estimada fue de 7.44 toneladas de CO₂ per cápita, con un intervalo de confianza del 95% BCa entre 6.29 y 9.86 y un intervalo percentil muy similar entre 6.07 y 9.20. Estos valores confirman que, en promedio, las emisiones de los países más ricos son sustancialmente más altas, y que la estimación es robusta aun cuando el método BCa ajusta el rango para contemplar la asimetría de la distribución.

En contraste, los países con bajo PIB per cápita (n = 119) muestran una media de 1.50 toneladas de CO₂ per cápita, con un intervalo de confianza del 95% BCa entre 1.23 y 1.85 y un intervalo percentil entre 1.21 y 1.81. Aquí, la concordancia casi total entre ambos métodos refleja una distribución más simétrica y un nivel de precisión mayor en la estimación. En conjunto, la tabla evidencia una diferencia marcada y consistente entre ambos grupos: los países más ricos emiten, en promedio, alrededor de cinco veces más CO₂ per cápita que los países más pobres. A continuación, presentamos esta misma información pero mostrando la distribución real de las estimaciones y localizndo los IC usando los dos diferentes métodos. 

# Visualización de los posibles IC

```{r}
# ============================================================
# 2. Función para generar distribución bootstrap y graficar
# ============================================================
plot_boot_ci <- function(df, titulo, R = 10000, seed = 123){
  set.seed(seed)
  b <- boot::boot(data = df, statistic = boot_mean, R = R)
  
  # Intervalos
  ci <- boot::boot.ci(b, type = c("bca", "perc"))
  lwr_perc <- ci$percent[4]; upr_perc <- ci$percent[5]
  lwr_bca  <- ci$bca[4];     upr_bca  <- ci$bca[5]
  
  # Convertir a tibble para ggplot
  tibble(val = b$t) %>%
    ggplot(aes(x = val)) +
    geom_histogram(aes(y = ..density..), bins = 50, fill = "skyblue", alpha = 0.6) +
    geom_density(color = "blue", size = 1) +
    geom_vline(xintercept = c(lwr_perc, upr_perc), color = "red", linetype = "dashed", size = 1) +
    geom_vline(xintercept = c(lwr_bca, upr_bca), color = "green", linetype = "dashed", size = 1) +
    labs(
      title = paste0("Distribución bootstrap de la media de CO2 - ", titulo),
      subtitle = "Rojo = Percentil | Verde = BCa",
      x = "Media bootstrap CO2 per cápita",
      y = "Densidad"
    ) +
    theme_minimal(base_size = 14)
}

# ============================================================
# 3. Ejecutar para Alto y Bajo PIB
# ============================================================
p1 <- plot_boot_ci(d1, "Alto PIB per cápita")
p2 <- plot_boot_ci(d2, "Bajo PIB per cápita")

# Mostrar lado a lado
library(patchwork)
p1 + p2

# Crear carpeta si no existe
dir.create(file.path(getwd(),"figuras"), recursive = TRUE, showWarnings = FALSE)

# Ruta de salida
fig_path <- file.path(getwd(),"figuras")

# Combinar en un solo objeto
p_comb <- p1 + p2

# Exportar en PNG
ggsave(filename = file.path(fig_path, "Distribucion_bootstrap_CO2.png"),
       plot = p_comb, width = 16, height = 6, dpi = 300)
```

Los gráficos muestran la distribución de las medias de emisiones de CO₂ obtenidas mediante bootstrap para los dos grupos de países. En el caso de los países con alto PIB per cápita, la distribución de las medias se concentra entre 6 y 9 toneladas de CO₂ per cápita, pero con una ligera asimetría hacia valores más altos. Esto se refleja en que el intervalo BCa (líneas verdes) es más amplio que el percentil (líneas rojas), extendiéndose un poco más hacia arriba para corregir el sesgo y cubrir la cola superior de la distribución. En otras palabras, aunque la estimación central es estable, el método BCa reconoce que puede haber mayor incertidumbre en los valores altos y lo incorpora en el intervalo.

En contraste, los países con bajo PIB per cápita presentan una distribución de medias centrada en torno a 1.5 toneladas de CO₂ per cápita, con una forma mucho más simétrica. En este caso, los intervalos percentil y BCa prácticamente coinciden, lo que indica que no hay un sesgo importante ni asimetría marcada en la distribución. Esto se traduce en estimaciones muy precisas y en intervalos de confianza estrechos. En conjunto, los gráficos ilustran no solo la diferencia de magnitud en las emisiones entre ambos grupos, sino también cómo la elección del método de intervalo puede afectar la interpretación, especialmente cuando la distribución no es perfectamente simétrica, como sucede en el grupo de mayor riqueza.

# Comportamiento del SE según la cantidad de repeticiones


```{r}
# ============================================================
# SE bootstrap vs número de réplicas (gráficos separados)
# ============================================================

library(dplyr)
library(purrr)
library(ggplot2)
library(boot)

# --- Función estadístico: media de CO2 (sin NA) ---
boot_mean <- function(data, indices) {
  mean(data[indices, "co2_2023", drop = TRUE])
}

# --- SE bootstrap para un R dado ---
boot_se_mean <- function(df, R, seed = 123){
  set.seed(seed)
  b <- boot::boot(data = df, statistic = boot_mean, R = R)
  sd(b$t)  # SE = desviación estándar de las réplicas
}

# --- Grid de R ---
grid_R <- seq(200, 30000, by = 100)

# --- Calcular SE por grupo ---
df_se_alto <- tibble(
  R  = grid_R,
  SE = map_dbl(grid_R, ~ boot_se_mean(d1, R = .x, seed = 123))
)

df_se_bajo <- tibble(
  R  = grid_R,
  SE = map_dbl(grid_R, ~ boot_se_mean(d2, R = .x, seed = 123))
)

# --- Función para detectar “punto de estabilización” ---
# Regla: mejora relativa < 1% por 3 pasos seguidos
find_plateau_R <- function(R, SE, rel_tol = 0.01, k = 3){
  if (length(SE) < k + 1) return(NA_real_)
  rel_drop <- pmax(0, -diff(SE) / head(SE, -1))  # reducción relativa paso a paso
  n <- length(rel_drop)
  for (i in seq(k, n)) {
    if (all(rel_drop[(i-k+1):i] < rel_tol)) {
      return(R[i + 1])  # R en el punto donde ya se estabilizó
    }
  }
  return(NA_real_)
}

R_star_alto <- find_plateau_R(df_se_alto$R, df_se_alto$SE, rel_tol = 0.01, k = 3)
R_star_bajo <- find_plateau_R(df_se_bajo$R, df_se_bajo$SE, rel_tol = 0.01, k = 3)

# --- Gráfico para ALTO PIB (solo) ---
p_alto <- ggplot(df_se_alto, aes(x = R, y = SE)) +
  geom_line(size = 1) +
  geom_point() +
  {if (!is.na(R_star_alto)) geom_vline(xintercept = R_star_alto, linetype = "dashed")} +
  {if (!is.na(R_star_alto)) annotate("text", x = R_star_alto, y = max(df_se_alto$SE),
                                     label = paste0("≈ estabiliza en R = ", R_star_alto),
                                     vjust = -0.5, angle = 90)} +
  labs(
    title = "SE bootstrap de la media de CO2 vs. R — Alto PIB per cápita",
    subtitle = "Línea punteada: punto de estabilización (mejora < 1% en 3 pasos)",
    x = "Número de réplicas bootstrap (R)",
    y = "SE bootstrap",
    caption = paste0("SE estabiliza en R = ", R_star_alto)
  ) +
  theme_minimal(base_size = 13)

# --- Gráfico para BAJO PIB (solo) ---
p_bajo <- ggplot(df_se_bajo, aes(x = R, y = SE)) +
  geom_line(size = 1) +
  geom_point() +
  {if (!is.na(R_star_bajo)) geom_vline(xintercept = R_star_bajo, linetype = "dashed")} +
  {if (!is.na(R_star_bajo)) annotate("text", x = R_star_bajo, y = max(df_se_bajo$SE),
                                     label = paste0("≈ estabiliza en R = ", R_star_bajo),
                                     vjust = -0.5, angle = 90)} +
  labs(
    title = "SE bootstrap de la media de CO2 vs. R — Bajo PIB per cápita",
    subtitle = "Línea punteada: punto de estabilización (mejora < 1% en 3 pasos)",
    x = "Número de réplicas bootstrap (R)",
    y = "SE bootstrap",
    caption = paste0("SE estabiliza en R = ", R_star_bajo)
  ) +
  theme_minimal(base_size = 13)

# Mostrar por separado
print(p_alto)
print(p_bajo)

# Crear carpeta si no existe
dir.create(file.path(getwd(), "figuras"), recursive = TRUE, showWarnings = FALSE)

# Ruta de salida
fig_path <- file.path(getwd(), "figuras")

# Guardar en PNG
ggsave(filename = file.path(fig_path, "SE_bootstrap_vs_R_AltoPIB.png"),
       plot = p_alto, width = 12, height = 6, dpi = 300, bg="white")

ggsave(filename = file.path(fig_path, "SE_bootstrap_vs_R_BajoPIB.png"),
       plot = p_bajo, width = 12, height = 6, dpi = 300, bg="white")

```


```{r}
# ============================================================
# Prueba t de diferencia de medias (unilateral a la derecha)
# ============================================================
t_test <- t.test(
  d1$co2_2023,
  d2$co2_2023,
  alternative = "greater",  # porque esperamos que Alto PIB > Bajo PIB
  var.equal = FALSE         # Welch t-test (no asumimos varianzas iguales)
)

print(t_test)
```
Dado que el p-valor ≈ 0.00000000005 es mucho menor que 0.05, rechazamos la hipótesis nula al 5 % de significancia.

Existe evidencia estadísticamente significativa de que los países con mayor PIB per cápita tienen mayores emisiones de CO₂ per cápita.

El intervalo de confianza no incluye el 0, reforzando la conclusión de que la diferencia media es positiva (alrededor de 5.94 toneladas de CO₂ per cápita).
