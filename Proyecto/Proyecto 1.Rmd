---
title: "Proyecto 1 - Visualización y Exploración de bases de datos"
author: " Henry Carvajal (201718787),Julian Delgado (201712798) , Mariana Villabona (201816559)"
date: "Visualización y Exploración de datos para ciencias sociales"
output: html_document
---

```{r Setup, include=FALSE}
# --- Limpiar entorno
rm(list = ls())
gc()
closeAllConnections()

# --- Cargar librerías necesarias
library("pacman")
require("pacman")
p_load( tidyverse, data.table, lubridate, readxl, ggthemes, plotly, janitor,ggplot2,openxlsx, writexl,stringi, patchwork, boot, skimr,tidyverse, readxl, ggthemes, plotly,sf,osmdata,dplyr, scales)

# --- Definir rutas
user <- Sys.getenv("USERNAME")
path <- setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
setwd(path)


# --- Cargar datos 
data <- file.path(path, "data/2025 JNA VP.xlsx")
col_mpios <- st_read("data/shapes.shp", quiet = TRUE)

data_migracion_hogares  <- read_excel(data, sheet = "Hogares") %>% clean_names()
data_migracion_personas <- read_excel(data, sheet = "Personas") %>% clean_names()
```

# Limpieza básica
```{r Ajuste texto}
limpiar_texto <- function(df) {
  df[] <- lapply(df, function(x) {
    if (is.character(x) | is.factor(x)) {
      x <- tolower(as.character(x))                        # pasar a minúsculas
      x <- stri_trans_general(x, "Latin-ASCII")            # quitar tildes
      return(x)
    } else {
      return(x)  # dejar igual las variables que no son texto
    }
  })
  return(as.data.frame(df))
}

# --- Aplicar a tus bases
data_migracion_hogares  <- limpiar_texto(data_migracion_hogares)
data_migracion_personas <- limpiar_texto(data_migracion_personas)
```

```{r Union bases}
data_migracion <- data_migracion_hogares %>%
  left_join(data_migracion_personas, by = "id_hogar")
```

```{r Agregar datos para hacer mapas}
std_name <- function(x) {
  x |>
    stri_trans_general("Latin-ASCII") |>   # quita tildes
    toupper() |>
    gsub("[[:punct:]]", " ", x = _) |>     # quita . , - / ( )
    gsub("\\s+", " ", x = _) |>            # colapsa espacios múltiples
    trimws()
}

# 1) data_migracion
data_migracion <- data_migracion %>%
  mutate(
    nombre_dpt = std_name(intro4),
    # normaliza cualquier variante que empiece por BOGOTA
    nombre_dpt = if_else(grepl("^BOGOTA", nombre_dpt), "BOGOTA", nombre_dpt)
  )

# 2) col_mpios -> deptos_sf
col_mpios <- st_make_valid(col_mpios)
deptos_sf <- col_mpios %>%
  mutate(
    nombre_dpt = std_name(nombre_dpt),
    # captura variantes comunes de Bogotá
    nombre_dpt = if_else(
      grepl("^SANTAFE DE BOGOTA", nombre_dpt) | grepl("^BOGOTA", nombre_dpt),
      "BOGOTA", nombre_dpt
    )
  ) %>%
  group_by(nombre_dpt) %>%
  summarise(
    dpto_code = first(dpto),
    geometry  = sf::st_union(geometry),
    .groups   = "drop"
  ) %>%
  sf::st_as_sf()

# 3) JOIN a nivel de dpto
data_migracion_sf <- data_migracion %>%
  left_join(deptos_sf, by = "nombre_dpt") %>%
  st_as_sf()

```

# PARTE I: EDA Y VISUALIZACIÓN AJUSTADA
## Exploración y creación de variables latentes
```{r A. ELIGIBILIDAD }
# PERSONAS POR DEPARTAMENTO ---------------------------------------
agg_migracion <- data_migracion %>%
  count(nombre_dpt, name = "n_personas")

mapa_sf <- deptos_sf %>%
  left_join(agg_migracion, by = "nombre_dpt")

mapa_personas <- ggplot(mapa_sf) +
  geom_sf(aes(fill = n_personas), color = "white", linewidth = 0.1) +
  scale_fill_viridis_c(option = "C", na.value = "grey90") +
  labs(
    title = "Conteo de registros por departamento",
    fill  = "Personas"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 14, face = "bold", margin = margin(b = 12)
    ),
    legend.position = "top",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.key.width = unit(2, "cm"),
    legend.background = element_rect(fill = alpha("white", 0.8), color = NA),
    legend.margin = margin(t = -5, b = 5)
  )
ggsave("stores/mapa_personas.png", mapa_personas, width = 7, height = 5, dpi = 300)
rm(mapa_sf,col_mpios,agg_migracion,mapa_sf,mapa_personas,std_name)


# EDAD Y SEXO -------------------
# Histograma Sexo
data_migracion$sexo_desagregado <- ifelse(data_migracion$demo2 == "Otro",
                                    "Otros",
                                    "Sexo biológico")

edades_hist <- ggplot(data_migracion, aes(x = demo1)) +
  geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7) +
  geom_text(
    stat = "bin",
    bins = 20,
    aes(label = ..count..),
    vjust = -0.2,    
    size = 2.0      
  ) +
  facet_wrap(~ sexo_desagregado + demo2, scales = "free_y") +
  labs(
    title = "Histograma de edad con cuentas por barra",
    x = "Edad",
    y = "Cuenta"
  ) +
  theme_minimal()
ggsave("stores/edades_histograma.png", edades_hist, width = 7, height = 5, dpi = 300)

# Densidad por sexo y edad
edades_plot <- ggplot(data_migracion, aes(x = demo1, fill = demo2)) +
  geom_density(alpha = 0.5) +
  labs(title = "Densidad de Edad por Sexo",
       x = "Edad",
       y = "Densidad") +
  theme_minimal()

# Guardar
ggsave("stores/edades_plot.png", edades_plot, width = 7, height = 5, dpi = 300)
rm(edades_hist, edades_plot)

# Probabilidades por edades
breaks <- pretty(range(data_migracion$demo1, na.rm = TRUE), n = 20)
dens_bins <- data_migracion %>%
  mutate(bin = cut(demo1, breaks = breaks, include.lowest = TRUE)) %>%
  group_by(demo2, bin) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(demo2) %>%
  mutate(freq = n / sum(n))  

# Rangos de edades 
data_migracion$rangos_edades <- cut(
  data_migracion$demo1,
  breaks = c(15, 25, 40, 70, Inf),
  labels = c("Joven", "Adulto Joven", "Adulto", "Adulto Mayor"),
  right = TRUE, include.lowest = TRUE
)
rm(dens_bins,breaks)

# JEFES DE HOGAR --------------------------------------
data_migracion %>%
  count(demo3) # Hay 8603 personas que reportan ser jefes de hogar

data_migracion %>%
  filter(!is.na(demo3) & demo3 != "") %>%
  count(demo5) # Todas las personas que no son jefes de hogar dicen poder
               # Responder por los miembros del hogar, coincide con                     
               # hogares sin jefes de hogar

# Identificar hogares sin jefes de hogar
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(no_tiene_jefe = as.integer(all(demo3 != "si" | is.na(demo3)))) %>%
  ungroup()

data_migracion %>%
  distinct(id_hogar, intro5, no_tiene_jefe) %>%
  group_by(intro5) %>%
  summarise(
    hogares_sin_jefe = sum(no_tiene_jefe),
    hogares_total = n(),
    porcentaje_sin_jefe = round(100 * hogares_sin_jefe / hogares_total, 1)
  ) %>%
  arrange(desc(hogares_sin_jefe)) # Resumen por ciudad

# Contar quién se puede reasignar cómo jefe de hogar. 
resumen_por_ciudad <- data_migracion %>%
  filter(no_tiene_jefe == 1) %>%                      
  group_by(intro5, id_hogar) %>%
  summarise(
    Puede_responder_por_el_hogar = any(demo5 == "si", na.rm = TRUE),    
    Total_sí = sum(demo5 == "si", na.rm = TRUE),    
    Total_miembros_promedio_por_hogar = n(),                                  # número de personas en ese hogar
    .groups = "drop"
  ) %>%
  group_by(intro5) %>%
  summarise(
    hogares_sin_jefe = n(),   
    hogares_con_al_menos_un_sí = sum(Puede_responder_por_el_hogar),  
    promedio_sí_por_hogar = round(mean(Total_sí), 2),
    miembros_promedio = round(mean(Total_miembros_promedio_por_hogar), 2),    # promedio de miembros por hogar
    .groups = "drop"
  ) %>%
  arrange(desc(hogares_sin_jefe)) # En todos los hogares sin jefe de hogar
                                  # los miembros reportan que pueden responder                                   # por el resto. Por lo que se asigna                                          # aleatoriamente a cualquier integrante 
                                  # cómo jefe de hogar. 
resumen_por_ciudad
rm(resumen_por_ciudad)

# Asignar un jefe de hogar
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    demo3 = ifelse(no_tiene_jefe == 1 & row_number() == 1, "si", demo3)
  ) %>%
  ungroup()

# INTENCIÓN DE MOVERSE---------------------------------------------
intencion_moverse <- data_migracion %>%
  pivot_longer(
    cols = c(demo21_ing_red,
             demo21_suf_disc,
             demo21_aum_prec,
             demo21_desal_viv,
             demo21_no_alim,
             demo21_no_acces_sal,
             demo21_of_lab,
             demo21_acc_edu,
             demo21_acc_edu_nna,
             demo21_otro_inten),
    names_to = "variable",
    values_to = "valor"
  ) %>%
  group_by(intro5, variable) %>%
  summarise(n_1 = sum(valor == 1, na.rm = TRUE), .groups = "drop") %>%
  arrange(intro5, variable)
rm(intencion_moverse)

# Moverse por Falta de ingresos
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    carencia_ingresos = as.integer(any(
      demo21_ing_red == 1 | demo21_aum_prec == 1 | demo21_of_lab == 1,
      na.rm = TRUE
    ))
  ) %>% ungroup()

# Moverse por carencias de servicios (incluye educación y alimentación)
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    carencia_servicios = as.integer(any( demo21_no_alim == 1 | 
        demo21_no_acces_sal == 1| demo21_acc_edu == 1|
        demo21_acc_edu_nna ==1),
      na.rm = TRUE
    )) %>% ungroup()

# Moverse por discriminación (incluye desalojo)
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    discriminacion = as.integer(any(
      demo21_suf_disc == 1 ),
      na.rm = TRUE
    )) %>% ungroup()

# Gráfico carencias por departamentos 
df_plot <- data_migracion %>%
  group_by(nombre_dpt) %>%
  summarise(
    carencia_ingresos  = sum(coalesce(carencia_ingresos, 0) == 1, na.rm = TRUE),
    carencia_servicios = sum(coalesce(carencia_servicios, 0) == 1, na.rm = TRUE),
    discriminacion     = sum(coalesce(discriminacion, 0) == 1, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(
    cols = c(carencia_ingresos, carencia_servicios, discriminacion),
    names_to = "motivo",
    values_to = "casos"
  ) %>%
  mutate(
    motivo = recode(motivo,
      carencia_ingresos  = "Carencia de ingresos",
      carencia_servicios = "Carencia de servicios",
      discriminacion     = "Discriminación"
    )
  ) %>%
  group_by(nombre_dpt) %>%
  mutate(total_dpto = sum(casos)) %>%
  ungroup() %>%
  mutate(nombre_dpt = reorder(nombre_dpt, total_dpto))

migrar_por <- ggplot(df_plot, aes(x = casos, y = nombre_dpt, fill = motivo)) +
  geom_col() +
  scale_fill_manual(
    values = c(
      "Carencia de ingresos"  = "darkred",
      "Carencia de servicios" = "#1F78B4",
      "Discriminación"        = "darkgray"
    )
  ) +
  labs(
    x = "Número de casos (personas)",
    y = "Departamento",
    fill = "Motivo",
    title = "Casos reportados por departamento y tipo de vulneración"
  ) +
  theme_minimal() +
  theme(
    panel.grid.major.y = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )
ggsave("stores/motivo_migrar_nuevamente.png", migrar_por, width = 8, height = 6, dpi = 300)
rm (df_plot, migrar_por)

# AÑOS ------------------------------------------------
data_migracion <- data_migracion %>%
  mutate(
    fecha_demo8 = ymd(demo8),   # convertir string a fecha
    meses_transcurridos = interval(fecha_demo8, today()) %/% months(1),
    anios_en_Col = meses_transcurridos / 12
  )
```

```{r B. INTENSIONES Y MOVIMIENTOS }
# MIGRAR EN PRÓXIMOS 6 MESES ----------------------------------------------
data_migracion <- data_migracion %>%
  mutate(
    `6M_sinmov`      = ifelse(demo22 == "no tienen la intencion de moverse", 1, 0), 
    `6M_Mudar_barrio`= ifelse(demo22 == "si, nos vamos a mudar de barrio al interior de esta ciudad", 1, 0),
    `6M_Depto`       = ifelse(demo22 == "si, nos vamos a cambiar a otro departamento al interior de colombia", 1, 0),
    `6M_Venezuela`   = ifelse(demo22 == "si, irnos a venezuela", 1, 0),
    `6M_OtroPais`    = ifelse(demo22 == "si, irnos a otro pais (diferente a venezuela)", 1, 0),
    `6M_MismoDpto`   = ifelse(demo22 == "si, nos vamos a cambiar de municipio pero en el mismo departamento actual", 1, 0)
  )

# HACE CUÁNTO TIEMPO RESIDE EN EL HOGAR ---------------------------------------
data_migracion <- data_migracion %>%
  mutate(
    meses_en_lugar = case_when(
      demo12a %in% c("no sabe", "prefiere no responder") ~ NA_character_,
      demo12a == "menos de 1 mes" ~ "<1",
      demo12a == "entre 1 mes y menos de 6 meses" ~ "1-6",
      demo12a == "entre 6 meses y menos de 1 ano" ~ "6-12",
      demo12a == "entre 1 ano y menos de 2 anos" ~ "12-24",
      demo12a == "entre 2 y menos de 3 anos" ~ "24-36",
      demo12a == "entre 3 y 10 anos" ~ "36-120",
      demo12a == "mas de 10 anos" ~ ">120",
      TRUE ~ NA_character_
    ),
    meses_en_lugar = factor(
      meses_en_lugar,
      levels = c("<1", "1-6", "6-12", "12-24", "24-36", "36-120", ">120"),
      ordered = TRUE
    )
  )

# RAZÓN POR LA QUE MIGRÓ A RESIDENCIA ACTUAL----------------------------------
data_migracion <- data_migracion %>%
  mutate(
    Migro_por_violencia = ifelse(demo17 %in% c(
      "la persona o alguien cercano fue victima 
      de violencia (extorsion, agresiones, etc.) o amenazas",
      "temor por la situacion general de violencia / inseguridad"), 1, 0),
    
    Migro_por_familia = ifelse(demo17 %in% c(
      "acompanar a otros miembros del hogar",
      "reunificacion familiar"), 1, 0),
    
    Migro_por_discriminacion = ifelse(demo17 %in% c(
      "salud mental o fisica",
      "temor de ser perseguido/a, agredido/a o discriminado/a"), 1, 0),
    
    Migro_por_trabajo = ifelse(demo17 == "trabajo", 1, 0),
    
    Migro_por_educacion = ifelse(demo17 == "educacion", 1, 0),
    
    Migro_por_des_natural = ifelse(demo17 == "desastres naturales", 1, 0),
    
    Migro_por_alimentos = ifelse(demo17 == "alimentos", 1, 0)
  )

# Gráfico
df_plot_mig <- data_migracion %>%
  group_by(nombre_dpt) %>%
  summarise(
    Migro_por_violencia      = sum(coalesce(Migro_por_violencia, 0) == 1, na.rm = TRUE),
    Migro_por_familia        = sum(coalesce(Migro_por_familia, 0) == 1, na.rm = TRUE),
    Migro_por_discriminacion = sum(coalesce(Migro_por_discriminacion, 0) == 1, na.rm = TRUE),
    Migro_por_trabajo        = sum(coalesce(Migro_por_trabajo, 0) == 1, na.rm = TRUE),
    Migro_por_educacion      = sum(coalesce(Migro_por_educacion, 0) == 1, na.rm = TRUE),
    Migro_por_des_natural    = sum(coalesce(Migro_por_des_natural, 0) == 1, na.rm = TRUE),
    Migro_por_alimentos      = sum(coalesce(Migro_por_alimentos, 0) == 1, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(
    cols = starts_with("Migro_por"),
    names_to = "motivo",
    values_to = "casos"
  ) %>%
  mutate(
    motivo = recode(motivo,
      Migro_por_violencia      = "Violencia / amenazas",
      Migro_por_familia        = "Reunificación familiar",
      Migro_por_discriminacion = "Discriminación / persecución",
      Migro_por_trabajo        = "Trabajo",
      Migro_por_educacion      = "Educación",
      Migro_por_des_natural    = "Desastres naturales",
      Migro_por_alimentos      = "Alimentos"
    )
  ) %>%
  group_by(nombre_dpt) %>%
  mutate(total_dpto = sum(casos)) %>%
  ungroup() %>%
  mutate(nombre_dpt = reorder(nombre_dpt, total_dpto))

migro_por <- ggplot(df_plot_mig, aes(x = casos, y = nombre_dpt, fill = motivo)) +
  geom_col() +
  labs(
    x = "Número de casos (personas)",
    y = "Departamento",
    fill = "Motivo de migración",
    title = "Motivos de migración por departamento"
  ) +
  scale_fill_manual(
    values = c(
      "Violencia / amenazas"           = "purple",
      "Reunificación familiar"         = "red",
      "Discriminación / persecución"   = "#7570b3",
      "Trabajo"                        = "darkblue",
      "Educación"                      = "gray",
      "Desastres naturales"            = "darkgreen",
      "Alimentos"                      = "salmon"
    )
  ) +
  theme_minimal() +
  theme(
    panel.grid.major.y = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )
ggsave("stores/motivo_migracion.png", migro_por, width = 8, height = 6, dpi = 300)
rm (df_plot_mig, migro_por)
```

```{r C. AGUA, SANEAMIENTO E HIGIENE (WASH)}
# ACCESO A AGUA-----------------------------
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    Acueducto_casa = as.integer(any(wash1 == "agua de tuberia por grifo", na.rm = TRUE)),
    AguaPublica_fueradecasa = as.integer(any(
      wash1 %in% c("perforaciones / pozos tubulares (publicos)",
                   "pilas o fuentes publicas (fuentes publicas)"),
      na.rm = TRUE
    )),
    Agua_FuentesNaturales = as.integer(any(
      wash1 %in% c("agua de lluvia",
                   "agua superficial (rio, quebrada, manantial, lago)"),
      na.rm = TRUE
    )),
    Agua_FuentesPrivadas = as.integer(any(
      wash1 %in% c("agua envasada, agua embotellada y agua en bolsitas",
                   "de pozo sin bomba, aljibe, jaguey o barreno; (no protegido)",
                   "suministro de agua, incluidos camiones cisterna y carros / tanques / tambores pequenos"),
      na.rm = TRUE
    )),
    Agua_NoAcceso = as.integer(any(wash1 == "no tiene acceso", na.rm = TRUE))
  ) %>%
  ungroup()

# AGUA EN VIVIENDA---------------------
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    Acceso_agua_casa = as.integer(any(wash01 == "si", na.rm = TRUE)),
    No_Acceso_agua_casa = as.integer(any(wash01 == "no", na.rm = TRUE)),
    Acceso_agua_casa_Otro = as.integer(any(wash01 %in% c("no sabe", "prefiere no responder"), na.rm = TRUE))
  ) %>%
  ungroup()

# TIEMPO PARA AGUA --------------------------------------
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    Agua_caminar_largo = as.integer(any(wash3 == "mas de 30 minutos", na.rm = TRUE)),
    Agua_caminar_corto = as.integer(any(wash3 == "menos de 30 minutos", na.rm = TRUE))
  ) %>%
  ungroup()

# SATISFACCIÓN NECESIDADES BÁSICAS AGUA-----------------
data_migracion <- data_migracion %>%
  mutate(
    Agua_Satisfaccion = case_when(
      wash5 == "si" ~ 1L,
      wash5 == "no" ~ 0L,
      TRUE ~ NA_integer_
    )
  )

# TIEMPO DE COBERTURA DEL SERVICIO ----------------------------
data_migracion <- data_migracion %>%
  mutate(
    Agua_CoberturaTotal = ifelse(
      wash6 == "las 24 horas del dia, los 7 dias de la semana", 1L, 0L
    ),
    Agua_CoberturaMedia = ifelse(
      wash6 %in% c("llega a diario pero solo a ciertas horas del 
                   dia/en horarios restringidos",
                   "las 24 horas de 4 a 6 dias a la semana"), 1L, 0L
    ),
    Agua_MalaCobertura = ifelse(
      wash6 %in% c("las 24 horas 1 a 2 dias a la semana",
                   "las 24 horas 3 dias a la semana"), 1L, 0L
    )
  )

# INFORMACIÓN SANEAMIENTO ---------------------------------------
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    # Calidad
    Saneamiento_deCalidad = as.integer(any(
      wash11 %in% c("inodoro conectado a alcantarillado",
                    "inodoro conectado a pozo septico"),
      na.rm = TRUE
    )),
    
    # No calidad
    Saneamiento_noCalidad = as.integer(any(
      wash11 %in% c("letrinas colgantes o inodoro con descarga directa a fuentes de agua (bajamar)",
                    "inodoro sin conexion (banos portatiles)",
                    "defecacion al aire libre",
                    "letrina de pozo con losa y plataforma",
                    "no tiene servicio sanitario, pero tiene un lugar gratuito y seguro",
                    "no tiene servicio sanitario y tiene que pagar el servicio",
                    "letrina improvisada"),
      na.rm = TRUE
    )),
    
    # Letrinas
    Saneamiento_Letrina = as.integer(any(
      wash11 %in% c("letrinas colgantes o inodoro con descarga directa a fuentes de agua (bajamar)",
                    "inodoro sin conexion (banos portatiles)",
                    "letrina de pozo con losa y plataforma",
                    "letrina improvisada"),
      na.rm = TRUE
    )),
    
    # Privado
    Saneamiento_Privado = as.integer(any(
      wash11 == "no tiene servicio sanitario y tiene que pagar el servicio",
      na.rm = TRUE
    )),
    
    # Uso público
    Saneamiento_UsoPublico = as.integer(any(
      wash11 %in% c("no tiene servicio sanitario, pero tiene un lugar gratuito y seguro",
                    "inodoro sin conexion (banos portatiles)"),
      na.rm = TRUE
    )),
    
    # Sin cobertura
    Saneamiento_SinCobertura = as.integer(any(
      wash11 %in% c("defecacion al aire libre",
                    "no tiene servicio sanitario, pero tiene un lugar gratuito y seguro",
                    "no tiene servicio sanitario y tiene que pagar el servicio"),
      na.rm = TRUE
    ))
  ) %>%
  ungroup()

# SERVICIO DE BASURA-----------------------------------------
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    Servicio_basuraPublico = as.integer(any(
      wash17 == "camion de basura municipal/punto de acopio formal", 
      na.rm = TRUE
    )),
    
    Servicio_basuraPrivado = as.integer(any(
      wash17 == "servicio informal (punto de acopio no autorizado, recicladores/cartoneros)", 
      na.rm = TRUE
    )),
    
    Servicio_Nobasura = as.integer(any(
      wash17 %in% c("no sabe",
                    "la tiran en la calle, via publica y/o rio",
                    "la queman o entierran"),
      na.rm = TRUE
    ))) %>%
  ungroup()

# AMBIENTE CONTAMINADO-------------------------------------------
data_migracion <- data_migracion %>%
  group_by(id_hogar) %>%
  mutate(
    AmbienteContaminado = as.integer(any(
      wash17 %in% c("la tiran en la calle, via publica y/o rio",
                    "la queman o entierran") |
      wash11 %in% c("defecacion al aire libre",
                    "letrinas colgantes o inodoro con descarga directa a fuentes de agua (bajamar)"),
      na.rm = TRUE
    ))
  ) %>%
  ungroup()

# PROBLEMAS PARA ACCEDER A ARTÍCULOS DE HIGIENE ---------------------
data_migracion <- data_migracion %>%
  mutate(
    wash20 = factor(
      wash20,
      levels = c("no (falta de jabon, lavamanos con agua)",
                 "si",
                 "utilizo gel antibacterial / toallas humedas / alcohol"),
      labels = c("No (falta de jabón/agua)", "Sí", "Gel/Toallas/Alcohol"),
      ordered = TRUE
    )
  )
```

```{r D. ESTADÍSTICAS DESCRIPTIVAS PRELIMINARES}
# Intención de migrar en 6 meses
resumen_intencion_6M <- data_migracion %>%
  group_by(nombre_dpt) %>%
  summarise(
    sinmov = sum(`6M_sinmov`, na.rm = TRUE),
    mudar_barrio = sum(`6M_Mudar_barrio`, na.rm = TRUE),
    depto = sum(`6M_Depto`, na.rm = TRUE),
    venezuela = sum(`6M_Venezuela`, na.rm = TRUE),
    otro_pais = sum(`6M_OtroPais`, na.rm = TRUE),
    mismo_dpto = sum(`6M_MismoDpto`, na.rm = TRUE),
    .groups = "drop"
  )
resumen_intencion_6M


# Tiempo de residencia en lugar en que se encuentra actualmente
resumen_meses_lugar <- data_migracion %>%
  group_by(nombre_dpt, meses_en_lugar) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(nombre_dpt) %>%
  mutate(
    pct = round(100 * n / sum(n), 1)   # porcentaje dentro de cada ciudad
  ) %>%
  arrange(nombre_dpt, meses_en_lugar)
resumen_meses_lugar

# Motivo por el que migró a residencia actual 
resumen_motivos <- data_migracion %>%
  group_by(nombre_dpt) %>%
  summarise(
    violencia      = sum(Migro_por_violencia, na.rm = TRUE),
    familia        = sum(Migro_por_familia, na.rm = TRUE),
    discriminacion = sum(Migro_por_discriminacion, na.rm = TRUE),
    trabajo        = sum(Migro_por_trabajo, na.rm = TRUE),
    educacion      = sum(Migro_por_educacion, na.rm = TRUE),
    des_natural    = sum(Migro_por_des_natural, na.rm = TRUE),
    alimentos      = sum(Migro_por_alimentos, na.rm = TRUE),
    .groups = "drop"
  )
# ACCESO A AGUA
resumen_agua <- data_migracion %>%
  distinct(id_hogar, nombre_dpt, Acueducto_casa, AguaPublica_fueradecasa,
           Agua_FuentesNaturales, Agua_FuentesPrivadas, Agua_NoAcceso) %>%
  group_by(nombre_dpt) %>%
  summarise(
    hogares_con_Acueducto = sum(Acueducto_casa, na.rm = TRUE),
    hogares_con_AguaPublica_fuera = sum(AguaPublica_fueradecasa, na.rm = TRUE),
    hogares_con_AguaNatural = sum(Agua_FuentesNaturales, na.rm = TRUE),
    hogares_con_AguaPrivada = sum(Agua_FuentesPrivadas, na.rm = TRUE),
    hogares_sin_Agua = sum(Agua_NoAcceso, na.rm = TRUE),
    total_hogares = n(),
    .groups = "drop"
  ) %>%
  mutate(
    pct_Acueducto = round(100 * hogares_con_Acueducto / total_hogares, 1),
    pct_AguaPublica_fuera = round(100 * hogares_con_AguaPublica_fuera / total_hogares, 1),
    pct_AguaNatural = round(100 * hogares_con_AguaNatural / total_hogares, 1),
    pct_AguaPrivada = round(100 * hogares_con_AguaPrivada / total_hogares, 1),
    pct_NoAcceso = round(100 * hogares_sin_Agua / total_hogares, 1)
  )

df_agua <- resumen_agua %>%
  select(nombre_dpt, total_hogares,
         hogares_con_Acueducto, hogares_con_AguaPublica_fuera,
         hogares_con_AguaNatural, hogares_con_AguaPrivada, hogares_sin_Agua) %>%
  pivot_longer(-c(nombre_dpt, total_hogares),
               names_to = "categoria", values_to = "n") %>%
  mutate(
    categoria = recode(categoria,
      hogares_con_Acueducto        = "Acueducto",
      hogares_con_AguaPublica_fuera = "Agua pública (fuera)",
      hogares_con_AguaNatural      = "Agua natural",
      hogares_con_AguaPrivada      = "Agua privada",
      hogares_sin_Agua             = "Sin acceso"
    ),
    nombre_dpt = fct_reorder(nombre_dpt, total_hogares)
  )

g_agua <- ggplot(df_agua, aes(x = nombre_dpt, y = n, fill = categoria)) +
  geom_col() +
  coord_flip() +
  labs(title = "Acceso a agua por departamento",
       subtitle = "Total de hogares por categoría",
       x = NULL, y = "Hogares", fill = NULL) +
  theme_minimal()
ggsave("stores/acceso_agua.png", g_agua, width = 10, height = 7, dpi = 300)
rm(g_agua, df_agua, resumen_agua,df_no_move,resumen_intencion_6M, 
   resumen_meses_lugar,resumen_momtivos)

# CAMINAR PARA ACCEDER A AGUA (CORTO < 30 MIN, LARGO > 30 MIN)
resumen_caminar <- data_migracion %>%
  distinct(id_hogar, nombre_dpt, Agua_caminar_largo, Agua_caminar_corto) %>%
  group_by(nombre_dpt) %>%
  summarise(
    hogares_largo = sum(Agua_caminar_largo, na.rm = TRUE),
    hogares_corto = sum(Agua_caminar_corto, na.rm = TRUE),
    total_hogares = n(),
    .groups = "drop"
  ) %>%
  mutate(
    pct_largo = round(100 * hogares_largo / total_hogares, 1),
    pct_corto = round(100 * hogares_corto / total_hogares, 1)
  ) %>%
  arrange(desc(total_hogares))
resumen_caminar
rm(resumen_caminar)

# ACCESO A SANEAMIENTO
resumen_saneamiento <- data_migracion %>%
  distinct(id_hogar, nombre_dpt, 
           Saneamiento_deCalidad, Saneamiento_noCalidad, 
           Saneamiento_Letrina, Saneamiento_Privado, 
           Saneamiento_UsoPublico, Saneamiento_SinCobertura) %>%
  group_by(nombre_dpt) %>%
  summarise(
    hogares_deCalidad     = sum(Saneamiento_deCalidad, na.rm = TRUE),
    hogares_noCalidad     = sum(Saneamiento_noCalidad, na.rm = TRUE),
    hogares_Letrina       = sum(Saneamiento_Letrina, na.rm = TRUE),
    hogares_Privado       = sum(Saneamiento_Privado, na.rm = TRUE),
    hogares_UsoPublico    = sum(Saneamiento_UsoPublico, na.rm = TRUE),
    hogares_SinCobertura  = sum(Saneamiento_SinCobertura, na.rm = TRUE),
    total_hogares         = n(),
    .groups = "drop"
  ) %>%
  mutate(
    pct_deCalidad    = round(100 * hogares_deCalidad / total_hogares, 1),
    pct_noCalidad    = round(100 * hogares_noCalidad / total_hogares, 1),
    pct_Letrina      = round(100 * hogares_Letrina / total_hogares, 1),
    pct_Privado      = round(100 * hogares_Privado / total_hogares, 1),
    pct_UsoPublico   = round(100 * hogares_UsoPublico / total_hogares, 1),
    pct_SinCobertura = round(100 * hogares_SinCobertura / total_hogares, 1)
  ) %>%
  arrange(desc(total_hogares))
resumen_saneamiento

df_sanea <- resumen_saneamiento %>%
  pivot_longer(
    c(hogares_deCalidad, hogares_noCalidad, hogares_Letrina,
      hogares_Privado, hogares_UsoPublico, hogares_SinCobertura),
    names_to = "categoria", values_to = "n"
  ) %>%
  mutate(
    categoria = recode(categoria,
      hogares_deCalidad    = "De calidad",
      hogares_noCalidad    = "Sin calidad",
      hogares_Letrina      = "Letrina",
      hogares_Privado      = "Privado",
      hogares_UsoPublico   = "Público",
      hogares_SinCobertura = "Sin cobertura"
    )
  )

g_sanea <- ggplot(df_sanea, aes(x = nombre_dpt, y = n, fill = categoria)) +
  geom_col() +
  coord_flip() +
  labs(title = "Acceso a saneamiento por departamento",
       subtitle = "Suma de hogares por categoría",
       x = "", y = "Hogares") +
  theme_minimal()
ggsave("stores/03_saneamiento_stack.png", g_sanea, width = 10, height = 6)
rm(resumen_saneamiento, df_sanea, g_sanea)

# Número de miembros en promedio por hogar
hogares <- data_migracion_sf %>%
  st_drop_geometry() %>%
  group_by(id_hogar, nombre_dpt) %>%
  summarise(personas_hogar = n(), .groups = "drop")

prom_dpto <- hogares %>% # Promedio por departamento
  group_by(nombre_dpt) %>%
  summarise(prom_personas_hogar = mean(personas_hogar), .groups = "drop")

mapa_prom <- deptos_sf %>%
  left_join(prom_dpto, by = "nombre_dpt")

personas_por_hogar <- ggplot(mapa_prom) +
  geom_sf(aes(fill = prom_personas_hogar), color = "white", linewidth = 0.2) +
  scale_fill_viridis_c(option = "C", na.value = "grey90",
                       name = "Promedio\npersonas\npor hogar") +
  labs(
    title = "Promedio de personas por hogar por departamento",
    subtitle = "Población migrante venezolana en Colombia",
    caption = "Fuente: data_migracion_sf"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    legend.position = "right"
  )
ggsave("stores/personas_por_hogar.png", personas_por_hogar, width = 8, height = 6, dpi = 300)
rm(personas_por_hogar,mapa_prom,prom_dpto,hogares,resumen_motivos)
```

```{r E. NECESIDADES A NIVEL DE HOGAR}
# NECESIDADES GENERALIZADAS  --------------------------------
vars_necesidades <- c("aap6a_aap6_empleo", "aap6a_aap6_alojamiento",
  "aap6a_aap6_comida", "aap6a_aap6_semillas", "aap6a_aap6_asistencia_tec", "aap6a_aap6_agua_med",
  "aap6a_aap6_articulos_hig", "aap6a_aap6_servicios_san",
  "aap6a_aap6_articulos_hog", "aap6a_aap6_educ", "aap6a_aap6_transporte", "aap6a_aap6_atencion_med",
  "aap6a_aap6_medicamentos", "aap6a_aap6_apoyo_psico", "aap6a_aap6_apoyo_psicolegal", "aap6a_aap6_deudas",
  "aap6a_aap6_comunicacion", "aap6a_aap6_otro", "aap6a_aap6_ninguno", "aap6a_aap6_nosabe",
  "aap6a_aap6_noresponde")

# Resumen de valores perdidos (NA) para esas variables
na_resumen_necesidades <- sapply(data_migracion[vars_necesidades], function(x) sum(is.na(x)))
na_resumen_necesidades  # No presenta valores nulos
rm(na_resumen_necesidades)

tabla_necesidades <- data_migracion %>%
  select(all_of(vars_necesidades)) %>%
  pivot_longer(cols = everything(),
               names_to = "variable",
               values_to = "respuesta") %>%
  group_by(variable) %>%
  summarise(
    conteo_1 = sum(respuesta == 1, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(proporcion = conteo_1 /  nrow(data_migracion)) %>%
  arrange(desc(proporcion)) %>%
  mutate(
    variable_label = recode(variable,
      "aap6a_aap6_comida"        = "Comida",
      "aap6a_aap6_empleo"        = "Empleo",
      "aap6a_aap6_alojamiento"   = "Alojamiento",
      "aap6a_aap6_atencion_med"  = "Atención médica",
      "aap6a_aap6_medicamentos"  = "Medicamentos",
      "aap6a_aap6_articulos_hog" = "Artículos del hogar",
      "aap6a_aap6_educ"          = "Educación",
      "aap6a_aap6_deudas"        = "Deudas",
      "aap6a_aap6_agua_med"      = "Agua",
      "aap6a_aap6_transporte"    = "Transporte",
      "aap6a_aap6_articulos_hig" = "Artículos de higiene",
      "aap6a_aap6_comunicacion"  = "Comunicación",
      "aap6a_aap6_apoyo_psicolegal" = "Apoyo psico-legal",
      "aap6a_aap6_apoyo_psico"   = "Apoyo psicológico",
      "aap6a_aap6_semillas"      = "Semillas",
      "aap6a_aap6_servicios_san" = "Servicios sanitarios",
      "aap6a_aap6_otro"          = "Otro",
      "aap6a_aap6_ninguno"       = "Ninguno",
      "aap6a_aap6_nosabe"        = "No sabe",
      "aap6a_aap6_noresponde"    = "No responde",
      "aap6a_aap6_asistencia_tec"= "Asistencia técnica",
      .default = variable
    )
  )

necesidades_hogares <- ggplot(tabla_necesidades, aes(x = reorder(variable_label, proporcion),
                              y = proporcion)) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = scales::percent(proporcion, accuracy = 0.1)),
            hjust = -0.1, size = 3.5) +
  coord_flip() +
  labs(
    title = "Necesidades reportadas por los hogares",
    x = "Necesidad",
    y = "Proporción de hogares"
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                     expand = expansion(mult = c(0, .1)))
ggsave("stores/necesidades_hogares.png", necesidades_hogares, width = 7, height = 5, dpi = 300)
rm(tabla_necesidades,vars_necesidades,necesidades_hogares)

# NECESIDADES AGRUPADAS POR TIPO  --------------------------------
tabla_necesidades_agrupada <- data_migracion %>%
  mutate(
    # 1. Medios de vida y economía
    grupo_medios = if_any(c(aap6a_aap6_empleo,
                            aap6a_aap6_deudas,
                            aap6a_aap6_semillas,
                            aap6a_aap6_asistencia_tec), ~ .x == 1),
    
    # 2. Vivienda y servicios básicos
    grupo_vivienda = if_any(c(aap6a_aap6_alojamiento,
                              aap6a_aap6_agua_med,
                              aap6a_aap6_servicios_san,
                              aap6a_aap6_transporte,
                              aap6a_aap6_comunicacion,
                              aap6a_aap6_articulos_hog), ~ .x == 1),
    
    # 3. Alimentación y artículos básicos
    grupo_alimentos = if_any(c(aap6a_aap6_comida), ~ .x == 1),
    
    # 4. Salud y bienestar
    grupo_salud = if_any(c(aap6a_aap6_atencion_med,
                           aap6a_aap6_medicamentos,
                           aap6a_aap6_apoyo_psico,,
                           aap6a_aap6_articulos_hig), ~ .x == 1),
    
    # 5. Protección y educación
    grupo_proteccion = if_any(c(aap6a_aap6_educ,
                                aap6a_aap6_apoyo_psicolegal), ~ .x == 1),
    
    # 6. No clasificable
    grupo_noclas = if_any(c(aap6a_aap6_otro,
                            aap6a_aap6_ninguno,
                            aap6a_aap6_nosabe,
                            aap6a_aap6_noresponde), ~ .x == 1)) 

# Resumen 
resumen_necesidades <- tabla_necesidades_agrupada %>%
  summarise(
    `Medios de vida y economía`   = sum(grupo_medios, na.rm = TRUE),
    `Vivienda y servicios básicos`= sum(grupo_vivienda, na.rm = TRUE),
    `Alimentación y artículos básicos` = sum(grupo_alimentos, na.rm = TRUE),
    `Salud y bienestar`           = sum(grupo_salud, na.rm = TRUE),
    `Protección y educación`      = sum(grupo_proteccion, na.rm = TRUE),
    `No clasificable`             = sum(grupo_noclas, na.rm = TRUE),
    total_hogares                 = n()
  ) %>%
  pivot_longer(cols = -total_hogares,
               names_to = "grupo",
               values_to = "conteo") %>%
  mutate(proporcion = conteo / total_hogares) %>%
  arrange(desc(proporcion))
resumen_necesidades

# NECESIDADES POR GEOGRAFÍA  --------------------------------
top3_grupos <- resumen_necesidades %>%
  slice_max(proporcion, n = 3) %>%
  pull(grupo)

data_migracion_sf_grupos <- data_migracion_sf %>%
  mutate(
    # 1. Medios de vida y economía
    grupo_medios = if_any(c(aap6a_aap6_empleo,
                            aap6a_aap6_deudas,
                            aap6a_aap6_semillas,
                            aap6a_aap6_asistencia_tec), ~ .x == 1),
    # 2. Vivienda y servicios básicos
    grupo_vivienda = if_any(c(aap6a_aap6_alojamiento,
                              aap6a_aap6_agua_med,
                              aap6a_aap6_servicios_san,
                              aap6a_aap6_transporte,
                              aap6a_aap6_comunicacion), ~ .x == 1),
    # 3. Alimentación y artículos básicos
    grupo_alimentos = if_any(c(aap6a_aap6_comida,
                               aap6a_aap6_articulos_hig,
                               aap6a_aap6_articulos_hog), ~ .x == 1),
    # 4. Salud y bienestar
    grupo_salud = if_any(c(aap6a_aap6_atencion_med,
                           aap6a_aap6_medicamentos,
                           aap6a_aap6_apoyo_psico), ~ .x == 1),
    # 5. Protección y educación
    grupo_proteccion = if_any(c(aap6a_aap6_educ,
                                aap6a_aap6_apoyo_psicolegal), ~ .x == 1),
    # 6. No clasificable
    grupo_noclas = if_any(c(aap6a_aap6_otro,
                            aap6a_aap6_ninguno,
                            aap6a_aap6_nosabe,
                            aap6a_aap6_noresponde), ~ .x == 1)
  )

map_nec_grupos <- data_migracion_sf_grupos %>%
  group_by(nombre_dpt) %>%
  summarise(
    `Medios de vida y economía`    = mean(grupo_medios, na.rm = TRUE),
    `Vivienda y servicios básicos` = mean(grupo_vivienda, na.rm = TRUE),
    `Alimentación y artículos básicos` = mean(grupo_alimentos, na.rm = TRUE),
    `Salud y bienestar`            = mean(grupo_salud, na.rm = TRUE),
    `Protección y educación`       = mean(grupo_proteccion, na.rm = TRUE),
    `No clasificable`              = mean(grupo_noclas, na.rm = TRUE),
    geometry = sf::st_union(geometry),
    .groups = "drop"
  )

plot_grupo <- function(sf_df, col_name) {
  ggplot(sf_df) +
    geom_sf(aes(fill = .data[[col_name]]), color = "white", linewidth = 0.25) +
    
    scale_fill_viridis_c(
      option = "magma",
      labels = percent_format(accuracy = 1),
      name = "% hogares",
      limits = c(0,1)
    )
    
    +
    labs(title = col_name) +
    theme_void(base_size = 11) +
    theme(
      legend.position = "right",
      plot.title = element_text(face = "bold")
    )
}

p_list <- lapply(top3_grupos, function(g) plot_grupo(map_nec_grupos, g))
p_grid <- p_list[[1]] | p_list[[2]] | p_list[[3]] +
  plot_annotation(title = "Necesidades agrupadas más frecuentes (%) — por departamento")

ggsave("stores/mapa_necesidades_agrupadas_grid.png", p_grid, width = 14, height = 5.2, dpi = 300)
rm(data_migracion_sf_grupos, map_nec_grupos, p_list, p_grid, plot_grupo, top3_grupos, tabla_necesidades_agrupada, resumen_necesidades)
```


```{r F. RECORTAR BASE A NIVEL DE INTERÉS (BOGOTÁ) y CREAR VARIABLE HACINAMIENTO}
# Filtrar Bogotá--------------------
data_bogota <- data_migracion %>%
  filter(intro5 == "bogota. d.c.")

# --- Quedarse con un registro por hogar, prefiriendo demo3 == "si"
data_filtrada <- data_bogota %>%
  group_by(id_hogar) %>%
  arrange(desc(demo3 == "si")) %>%  # ordena poniendo primero los que tienen demo3 == "si"
  slice(1) %>%                      # toma el primer registro de cada hogar
  ungroup()

# Calcular índice de hacinamiento ---------------------------
data_filtrada <- data_filtrada %>%
  mutate(
    personas_cuarto = miembros1 / alojamiento7,
    hacinamiento = case_when(
      is.na(personas_cuarto) ~ NA_character_,
      personas_cuarto <= 2 ~ "Sin hacinamiento",
      personas_cuarto > 2 & personas_cuarto <= 3 ~ "Moderado",
      personas_cuarto > 3 ~ "Crítico"
    )
  )

# Revisar valores vacios índice de hacinamiento ---------------------------
table(data_filtrada$hacinamiento, useNA = "ifany")

# Variables únicas (riesgo desalojo, intención moverse, tiempo residencia)
vars_unica <- c("miembros1", "alojamiento7")

# NA en variables únicas
na_resumen <- sapply(data_filtrada[vars_unica], function(x) sum(is.na(x)))
na_resumen

# Orden lógico de categorías
data_filtrada$hacinamiento <- factor(
  data_filtrada$hacinamiento,
  levels = c("Sin hacinamiento", "Moderado", "Crítico")
)

# Distribución y gráfico de barras hacinamiento --------------------------
hacinamiento_resumen <- data_filtrada %>%
  group_by(hacinamiento) %>%
  summarise(Frecuencia = n()) %>%
  mutate(Proporcion = round(100 * Frecuencia / sum(Frecuencia), 1))
hacinamiento_resumen

hacinamiento <- ggplot(data_filtrada, aes(x = hacinamiento, fill = hacinamiento)) +
  geom_bar() +
  theme_minimal() +
  labs(
    title = "Distribución del hacinamiento en Bogotá",
    x = "Categoría de hacinamiento",
    y = "Número de hogares"
  ) +
  theme(legend.position = "none")
ggsave("stores/Hacinamiento.png", hacinamiento, width = 7, height = 5, dpi = 300)
rm(hacinamiento, na_resumen, vars_unica,var_names, hacinamiento_resumen)
```

## Análisis de Correlación Hacinamiento vs Ingresos, Productos Finacnieros y Gastos del Hogar.
```{r G. CORRELACIÓN VARIABLE HACINAMIENTO CON VARIABLES}
# INTENCIÓN DE MOVERSE Y HACINAMIENTO -------------------------------------------
df_bubble <- data_filtrada %>%
  filter(demo22 != "no tienen la intencion de moverse") %>%
  count(hacinamiento, demo22, name = "n") %>%
  group_by(hacinamiento) %>%
  mutate(pct = n / sum(n),
         pct_lab = percent(pct, accuracy = 0.1)) %>%
  ungroup()

df_bubble

p_bubble <- ggplot(df_bubble, aes(x = hacinamiento, y = demo22, size = pct, color = hacinamiento)) +
  geom_point(alpha = 0.75) +
  scale_size_area(name = "% dentro de hacinamiento", labels = percent_format(accuracy = 1),
                  max_size = 18) +
  labs(title = "Hacinamiento vs intención de movilizarse en 6 meses",
       x = "Nivel de hacinamiento", y = "Intención de movilidad (demo22)") +
  theme_minimal(base_size = 12)
p_bubble
ggsave("stores/hacinamiento_movilidad_bubble.png", p_bubble, width = 12, height = 6, dpi = 300)
rm(df_bubble,p_bubble)
```

```{r H. CORRELACIÓN VARIABLE HACINAMIENTO CON INGRESOS y ACCESO A PRODUCTOS FINANCIEROS}
# RELACIÓN HACINAMIENTO CON VARIABLES DE INGRESO --------------------------- 
vars_financieras <- c(
  # Fuentes de ingreso
  "mediosvida5_mediosvida5_prestamos","mediosvida5_mediosvida5_ahorros",
  "mediosvida5_mediosvida5_trabajo", "mediosvida5_mediosvida5_asistencia",
  "mediosvida5_mediosvida5_apoyocomunidad","mediosvida5_mediosvida5_venderbienes",
  "mediosvida5_mediosvida5_donaciones","mediosvida5_mediosvida5_notiene", "mediosvida5_mediosvida5_otra",   
  
  # Productos financieros
  "mediosvida7_mediosvida7_cuenta_ahorro", "mediosvida7_mediosvida7_cuenta_corriente",
  "mediosvida7_mediosvida7_billetera_electronica","mediosvida7_mediosvida7_deposito_bajo_monto",
  "mediosvida7_mediosvida7_microcredito", "mediosvida7_mediosvida7_prestamo_vivienda",
  "mediosvida7_mediosvida7_prestamo_de_libre_inversion", "mediosvida7_mediosvida7_tarjeta_de_credito",
  "mediosvida7_mediosvida7_otro", "mediosvida7_mediosvida7_ninguno", 
  "mediosvida7_mediosvida7_no_sabe",  "mediosvida7_mediosvida7_noresponde"
)
# NAs por variable
na_financieras <- sapply(vars_financieras, \(v) sum(is.na(data_migracion[[v]])))
na_financieras <- data.frame(variable = names(na_financieras), na_count = as.integer(na_financieras))

# Función para generar gráficos asociados a ingresos
make_plot_finanzas <- function(df, prefix, titulo, filename) {
  cols <- grep(paste0("^", prefix), names(df), value = TRUE)
  
  df_long <- df %>%
    # estandariza a binario por si viene "1" o 1
    mutate(across(all_of(cols), ~ as.integer(. %in% c(1, "1")))) %>%
    group_by(hacinamiento) %>%
    summarise(across(all_of(cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop") %>%
    pivot_longer(-hacinamiento, names_to = "producto", values_to = "conteo") %>%
    group_by(hacinamiento) %>%
    mutate(total = sum(conteo), porcentaje = conteo / total) %>%
    ungroup() %>%
    mutate(
      # limpia prefijos largos en nombres de columnas
      producto = str_remove(producto, paste0("^", prefix, "_", prefix, "_")),
      producto = str_remove(producto, paste0("^", prefix, "_"))
    )
  p <- ggplot(df_long, aes(x = hacinamiento, y = porcentaje, fill = producto)) +
    geom_col() +
    scale_y_continuous(labels = percent_format(accuracy = 1)) +
    labs(title = titulo, x = "Nivel de hacinamiento", y = "Porcentaje dentro de hacinamiento", fill = NULL) +
    theme_minimal(base_size = 12)
  
  if (!dir.exists("stores")) dir.create("stores", recursive = TRUE)
  ggsave(file.path("stores", filename), p, width = 11, height = 6, dpi = 300)
  p
}

# --- Aplicar función para MV5 (fuentes de ingreso) y MV7 (productos financieros) ---
p_mv5 <- make_plot_finanzas(
  data_filtrada,
  "mediosvida5",
  "Fuentes de ingreso del hogar (porcentaje dentro de cada nivel de hacinamiento)",
  "mv5_fuentes_ingreso_porcentaje.png"
)

p_mv7 <- make_plot_finanzas(
  data_filtrada,
  "mediosvida7",
  "Acceso/uso de productos financieros (porcentaje dentro de cada nivel de hacinamiento)",
  "mv7_productos_financieros_porcentaje.png"
)
rm(make_plot_finanzas, p_mv5, p_mv7,na_financieras)
```

```{r I. CORRELACIÓN VARIABLE HACINAMIENTO CON GASTOS/DIFICULTADES AL INTERIOR DEL HOGAR}
# SOLO BOGOTÁ 
tabla_necesidades_agrupada <- data_filtrada %>%
  mutate(
    # 1. Medios de vida y economía
    grupo_medios = if_any(c(aap6a_aap6_empleo,
                            aap6a_aap6_deudas,
                            aap6a_aap6_semillas,
                            aap6a_aap6_asistencia_tec), ~ .x == 1),
    # 2. Vivienda y servicios básicos
    grupo_vivienda = if_any(c(aap6a_aap6_alojamiento,
                              aap6a_aap6_agua_med,
                              aap6a_aap6_servicios_san,
                              aap6a_aap6_transporte,
                              aap6a_aap6_comunicacion,aap6a_aap6_articulos_hog), ~ .x == 1),
    # 3. Alimentación y artículos básicos
    grupo_alimentos = if_any(c(aap6a_aap6_comida), ~ .x == 1),
    
    # 4. Salud y bienestar
    grupo_salud = if_any(c(aap6a_aap6_atencion_med,
                           aap6a_aap6_medicamentos,
                           aap6a_aap6_apoyo_psico,aap6a_aap6_articulos_hig), ~ .x == 1),
    
    # 5. Protección y educación
    grupo_proteccion = if_any(c(aap6a_aap6_educ,
                                aap6a_aap6_apoyo_psicolegal), ~ .x == 1),
    
    # 6. No clasificable
    grupo_noclas = if_any(c(aap6a_aap6_otro,
                            aap6a_aap6_ninguno,
                            aap6a_aap6_nosabe,
                            aap6a_aap6_noresponde), ~ .x == 1)
  ) 

## Resumen de tipo de necesidad
resumen_necesidades <- tabla_necesidades_agrupada %>%
  summarise(
    `Medios de vida y economía`   = sum(grupo_medios, na.rm = TRUE),
    `Vivienda y servicios básicos`= sum(grupo_vivienda, na.rm = TRUE),
    `Alimentación y artículos básicos` = sum(grupo_alimentos, na.rm = TRUE),
    `Salud y bienestar`           = sum(grupo_salud, na.rm = TRUE),
    `Protección y educación`      = sum(grupo_proteccion, na.rm = TRUE),
    `No clasificable`             = sum(grupo_noclas, na.rm = TRUE),
    total_hogares                 = n()
  ) %>%
  pivot_longer(cols = -total_hogares,
               names_to = "grupo",
               values_to = "conteo") %>%
  mutate(proporcion = conteo / total_hogares) %>%
  arrange(desc(proporcion))

resumen_necesidades

# Calcular totales por tipo de hacinamiento (para base de porcentajes)
totales <- tabla_necesidades_agrupada %>%
  group_by(hacinamiento) %>%
  summarise(total_hogares = n(), .groups = "drop")

# Transformar a formato largo y calcular porcentajes
necesidades_hacinamiento <- tabla_necesidades_agrupada %>%
  select(hacinamiento,
         grupo_medios,
         grupo_vivienda,
         grupo_alimentos,
         grupo_salud,
         grupo_proteccion,
         grupo_noclas) %>%
  pivot_longer(
    cols = starts_with("grupo"),
    names_to = "grupo",
    values_to = "valor"
  ) %>%
  filter(valor == TRUE | valor == 1) %>%
  group_by(hacinamiento, grupo) %>%
  summarise(conteo = n(), .groups = "drop") %>%
  left_join(totales, by = "hacinamiento") %>%
  mutate(
    pct = (conteo / total_hogares) * 100,
    grupo = recode(grupo,
      grupo_medios     = "Medios de vida y economía",
      grupo_vivienda   = "Vivienda y servicios básicos",
      grupo_alimentos  = "Alimentación y artículos básicos",
      grupo_salud      = "Salud y bienestar",
      grupo_proteccion = "Protección y educación",
      grupo_noclas     = "No clasificable"
    )
  )

# Gráfica: barras agrupadas por tipo de hacinamiento dentro de cada necesidad
necesidades_hacinamiento <- ggplot(necesidades_hacinamiento, aes(x = grupo, y = pct, fill = hacinamiento)) +
  geom_col(position = "dodge") +
  labs(
    title = "Porcentaje de hogares con necesidades según tipo de hacinamiento",
    x = "Grupo de necesidad",
    y = "Porcentaje de hogares",
    fill = "Tipo de hacinamiento"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    axis.title.x = element_text(margin = margin(t = 10))
  )
ggsave("stores/nec_hacinamiento_corr_grid.png", necesidades_hacinamiento, width = 14, height = 6, dpi = 300)

# Gráfico de correlaciones
resumen_necesidades <- tabla_necesidades_agrupada %>%
  summarise(
    `Medios de vida y economía`   = sum(grupo_medios, na.rm = TRUE),
    `Vivienda y servicios básicos`= sum(grupo_vivienda, na.rm = TRUE),
    `Alimentación y artículos básicos` = sum(grupo_alimentos, na.rm = TRUE),
    `Salud y bienestar`           = sum(grupo_salud, na.rm = TRUE),
    `Protección y educación`      = sum(grupo_proteccion, na.rm = TRUE),
    `No clasificable`             = sum(grupo_noclas, na.rm = TRUE),
    total_hogares                 = n()
  ) %>%
  pivot_longer(cols = -total_hogares,
               names_to = "grupo",
               values_to = "conteo") %>%
  mutate(proporcion = conteo / total_hogares) %>%
  arrange(desc(proporcion))

resumen_necesidades

# Calcular totales por tipo de hacinamiento (para base de porcentajes)
totales <- tabla_necesidades_agrupada %>%
  group_by(hacinamiento) %>%
  summarise(total_hogares = n(), .groups = "drop")

# Transformar a formato largo y calcular porcentajes
df_necesidades_hacinamiento <- tabla_necesidades_agrupada %>%
  select(hacinamiento,
         grupo_medios,
         grupo_vivienda,
         grupo_alimentos,
         grupo_salud,
         grupo_proteccion,
         grupo_noclas) %>%
  pivot_longer(
    cols = starts_with("grupo"),
    names_to = "grupo",
    values_to = "valor"
  ) %>%
  filter(valor == TRUE | valor == 1) %>%
  group_by(hacinamiento, grupo) %>%
  summarise(conteo = n(), .groups = "drop") %>%
  left_join(totales, by = "hacinamiento") %>%
  mutate(
    pct = (conteo / total_hogares) * 100,
    grupo = recode(grupo,
      grupo_medios     = "Medios de vida y economía",
      grupo_vivienda   = "Vivienda y servicios básicos",
      grupo_alimentos  = "Alimentación y artículos básicos",
      grupo_salud      = "Salud y bienestar",
      grupo_proteccion = "Protección y educación",
      grupo_noclas     = "No clasificable"
    )
  )

# Gráfica: barras agrupadas por tipo de hacinamiento dentro de cada necesidad
g_necesidades_hacinamiento <- ggplot(df_necesidades_hacinamiento, aes(x = grupo, y = pct, fill = hacinamiento)) +
  geom_col(position = "dodge") +
  labs(
    title = "Porcentaje de hogares con necesidades según tipo de hacinamiento (Bogotá)",
    x = "Grupo de necesidad",
    y = "Porcentaje de hogares",
    fill = "Tipo de hacinamiento"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    axis.title.x = element_text(margin = margin(t = 10))
  )
ggsave("stores/nec_hacinamiento_barras_bogota.png", g_necesidades_hacinamiento, width = 14, height = 6, dpi = 300)

# Gráfico de correlaciones
hm_pct <- df_necesidades_hacinamiento %>%
  mutate(grupo = factor(grupo)) %>%
  ggplot(aes(x = hacinamiento, y = grupo, fill = pct/100)) +
  geom_tile(color = "white", linewidth = 0.2) +
  geom_text(aes(label = percent(pct/100, accuracy = 0.1)), size = 3) +
  scale_fill_viridis_c(option = "magma", limits = c(0,1),
                       labels = percent_format(accuracy = 1), name = "% dentro de hacinamiento") +
  labs(title = "A) Participación por celda (%)") +
  theme_minimal(base_size = 11) +
  theme(panel.grid = element_blank(), axis.title = element_blank())

#  Residuales de Pearson 
tab_cont <- df_necesidades_hacinamiento %>%
  select(hacinamiento, grupo, conteo) %>%
  pivot_wider(names_from = hacinamiento, values_from = conteo, values_fill = 0) %>%
  as.data.frame()

rownames(tab_cont) <- tab_cont$grupo
tab_cont$grupo <- NULL
M <- as.matrix(tab_cont)

# Esperados y residuales
row_tot <- rowSums(M); col_tot <- colSums(M); N <- sum(M)
E <- outer(row_tot, col_tot) / N
R <- (M - E) / sqrt(pmax(E, 1e-9))  # evita divisiones por cero

df_resid <- as.data.frame(R) |>
  tibble::rownames_to_column("grupo") |>
  pivot_longer(-grupo, names_to = "hacinamiento", values_to = "residual") # Formato largo

hm_res <- ggplot(df_resid, aes(x = hacinamiento, y = grupo, fill = residual)) +
  geom_tile(color = "white", linewidth = 0.2) +
  # valores positivos = sobre-representado; negativos = infra-representado
  scale_fill_gradient2(low = "#2166AC", mid = "white", high = "#B2182B",
                       midpoint = 0, name = "Residual") +
  labs(title = "B) Residuales de Pearson (sobre/infra-representación)") +
  theme_minimal(base_size = 11) +
  theme(panel.grid = element_blank(), axis.title = element_blank())

p_grid <- hm_pct | hm_res
p_grid <- p_grid + plot_annotation(
  title = "Hacinamiento vs grupos de necesidades: % por celda y residuales de Pearson (Bogotá)"
)
ggsave("stores/nec_hacinamiento_corr_grid_bogota.png", p_grid, width = 14, height = 6, dpi = 300)

rm(tab_cont, M, row_tot, col_tot, N, E, R, df_resid, hm_pct, hm_res, p_grid,
   tabla_necesidades_agrupada, totales, resumen_necesidades, g_necesidades_hacinamiento,
   df_necesidades_hacinamiento, base_bogota)
```

```{r J. CORRELACIÓN VARIABLE HACINAMIENTO CON GASTO EN VIVIENDA}
# Resumen de la variable de gasto en vivienda
summary(data_filtrada$san53_viv)
# Revisar cuántos NA hay
sum(is.na(data_filtrada$san53_viv))

# --- Resumen estadístico del gasto en vivienda
resumen_gasto_viv <- data_filtrada %>%
  group_by(hacinamiento) %>%
  summarise(
    n = n(),
    media = mean(san53_viv, na.rm = TRUE),
    mediana = median(san53_viv, na.rm = TRUE),
    p25 = quantile(san53_viv, 0.25, na.rm = TRUE),
    p75 = quantile(san53_viv, 0.75, na.rm = TRUE),
    maximo = max(san53_viv, na.rm = TRUE),
    .groups = "drop"
  )

# --- Resumen estadístico del gasto en vivienda
print(resumen_gasto_viv) 

# --- Crear variable de gasto total
data_filtrada <- data_filtrada %>%
  mutate(
    gasto_total = rowSums(across(c(san52_alim, san53_viv, san54_serv,
                                   san55_sal, san56_edu, san57_otros)), na.rm = TRUE),
    pct_vivienda = if_else(gasto_total > 0, (san53_viv / gasto_total) * 100, NA_real_)
  )

# --- Revisar tabla de resumen
resumen_pct_viv <- data_filtrada %>%
  group_by(hacinamiento) %>%
  summarise(
    n = n(),
    media = mean(pct_vivienda, na.rm = TRUE),
    mediana = median(pct_vivienda, na.rm = TRUE),
    p25 = quantile(pct_vivienda, 0.25, na.rm = TRUE),
    p75 = quantile(pct_vivienda, 0.75, na.rm = TRUE),
    maximo = max(pct_vivienda, na.rm = TRUE),
    .groups = "drop"
  )

# --- Revisar NA en variables de gasto
colSums(is.na(data_filtrada[, c("san52_alim", "san53_viv", 
                                "san54_serv", "san55_sal", 
                                "san56_edu", "san57_otros")]))

# --- Revisar NA en gasto_total y pct_vivienda
sum(is.na(data_filtrada$gasto_total))
sum(is.na(data_filtrada$pct_vivienda))

# --- Proporción de NA en pct_vivienda
mean(is.na(data_filtrada$pct_vivienda))

print(resumen_pct_viv)

# GRÁFICO HACINAMIENTO Y GASTO EN VIVIENDA
gasto_vivienda <- ggplot(data_filtrada, aes(x = hacinamiento, y = pct_vivienda, fill = hacinamiento)) +
  geom_violin(trim = FALSE, alpha = 0.6) +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  theme_minimal(base_size = 12) +
  labs(
    title = "Porcentaje del gasto total destinado a vivienda",
    x = "Nivel de hacinamiento",
    y = "% del gasto en vivienda"
  ) +
  scale_y_continuous(labels = label_percent(scale = 1)) + 
  theme(legend.position = "none")
ggsave("stores/gasto_vivienda.png", gasto_vivienda, width = 14, height = 6, dpi = 300)
```

```{r PERSONAS: MEDIOS DE VIDA E INTEGRACION}
vars_mediosvida <- c(
  "miembros21",  # Tiempo dedicado 
  "miembros22",  # Horas trabajadas
  "miembros23",  # Trabajaria mas
  "miembros23a",  # quiere trabajar mas 
  "miembros30",  # Cuenta con contrato formal
  "miembros30b",   # Seguridad social en salud
  "miembros31a",  # Seguridad social pension
  "miembros21b",  # Rango de ingresos
  "miembros24a",  # Reporto dificultades para encontrar trabajo
  "miembros24b_dificultades_nodocu",  ### Razones ####
  "miembros24b_dificultades_familia",
  "miembros24b_dificultades_discrimina",
  "miembros24b_dificultades_noconocimi",
  "miembros24b_dificultades_noempleo",
  "miembros24b_dificultades_noofertas",
  "miembros24b_dificultades_noexperiencia",
  "miembros24b_dificultades_otra",
  "miembros24b_nosabe",
  "miembros24b_noresponde" #############
)

# Resumen de valores perdidos (NA) en estas variables
na_resumen_mediosvida <- sapply(data_bogota[vars_mediosvida], function(x) sum(is.na(x)))
na_resumen_mediosvida
rm(na_resumen_mediosvida)

# IMPUTAR NAS------------------------
vars_24b <- c(
  "miembros24b_dificultades_nodocu",
  "miembros24b_dificultades_familia",
  "miembros24b_dificultades_discrimina",
  "miembros24b_dificultades_noconocimi",
  "miembros24b_dificultades_noempleo",
  "miembros24b_dificultades_noofertas",
  "miembros24b_dificultades_noexperiencia",
  "miembros24b_dificultades_otra",
  "miembros24b_nosabe",
  "miembros24b_noresponde"
)

data_bogota <- data_bogota %>%
  rowwise() %>%
  mutate(
    across(all_of(vars_24b), ~ case_when(
      #En caso de que no haya reportado dificultades con miembros24a = no, no ha buscado empleo, no sabe
      miembros24a %in% c("no", "no ha buscado empleo", "no sabe") & is.na(.x) ~ 0,
      
      # Pero si respondio que si encontro dificultades (miembros24a = si) y hay al menos una de las variables igual a 1, se asume que el resto no ocurrieron
      miembros24a == "si" & any(c_across(all_of(vars_24b)) == 1, na.rm = TRUE) & is.na(.x) ~ 0,
      
      TRUE ~ .x
    ))
  ) %>%
  ungroup()

# Resumen de valores perdidos (NA) en estas variables
na_resumen_mediosvida <- sapply(data_bogota[vars_mediosvida], function(x) sum(is.na(x)))

# ESTADÍSTICAS -------------------------------------------
vars_principales <- c(
  "miembros21",
  "miembros30",
  "miembros30b",
  "miembros31a",
  "miembros21b"
)

tabla_cruzada_miembros21 <- data_bogota %>%
  count(miembros21, meses_en_lugar) %>%
  pivot_wider(
    names_from = meses_en_lugar,
    values_from = n,
    values_fill = 0
  )

tabla_cruzada_miembros21


tabla_cruzada_miembros30 <- data_bogota %>%
  count(miembros30, meses_en_lugar) %>%
  pivot_wider(
    names_from = meses_en_lugar,
    values_from = n,
    values_fill = 0
  )
tabla_cruzada_miembros30


tabla_cruzada_miembros30b <- data_bogota %>%
  count(miembros30b, meses_en_lugar) %>%
  pivot_wider(
    names_from = meses_en_lugar,
    values_from = n,
    values_fill = 0
  )
tabla_cruzada_miembros30b

tabla_cruzada_miembros31a <- data_bogota %>%
  count(miembros31a, meses_en_lugar) %>%
  pivot_wider(
    names_from = meses_en_lugar,
    values_from = n,
    values_fill = 0
  )
tabla_cruzada_miembros31a


tabla_cruzada_miembros21b <- data_bogota %>%
  count(miembros21b, meses_en_lugar) %>%
  pivot_wider(
    names_from = meses_en_lugar,
    values_from = n,
    values_fill = 0
  )
tabla_cruzada_miembros21b

# SEGURIDAD SOCIAL ---------------------------------------
p1 <- ggplot(data_bogota %>%
               filter(!is.na(miembros30b)) %>%
               count(meses_en_lugar, miembros30b) %>%
               mutate(miembros30b = str_wrap(miembros30b, width = 25)), # salto de línea
             aes(x = meses_en_lugar, y = n, fill = miembros30b)) +
  geom_col(position = "dodge") +
  labs(
    title = "Acceso a seguridad social en salud",
    x = "Meses en el lugar",
    y = "Número de hogares",
    fill = "Respuesta"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 9),
    legend.text = element_text(size = 8)
  )

# PENSION ----------------------------------------------------
p2 <- ggplot(data_bogota %>%
               filter(!is.na(miembros31a)) %>%
               count(meses_en_lugar, miembros31a) %>%
               mutate(miembros31a = str_wrap(miembros31a, width = 25)), # salto de línea
             aes(x = meses_en_lugar, y = n, fill = miembros31a)) +
  geom_col(position = "dodge") +
  labs(
    title = "Acceso a seguridad social en pensiones",
    x = "Meses en el lugar",
    y = "Número de hogares",
    fill = "Respuesta"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    plot.title = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 9),
    legend.text = element_text(size = 8)
  )

g_seg_soc <- gridExtra::arrangeGrob(p1, p2, ncol = 2)
ggsave("stores/seguridad_social_bogota.png", g_seg_soc, width = 12, height = 5, dpi = 300)

# INGRESOS A LO LARGO DEL TIEMPO -------------------------------------
g_ingresos <- ggplot(data_bogota %>%
         filter(!is.na(miembros21b)) %>%
         count(meses_en_lugar, miembros21b) %>%
         mutate(miembros21b = str_wrap(miembros21b, width = 30)),  # ajusta ancho del texto
       aes(x = meses_en_lugar, y = n, fill = miembros21b)) +
  geom_col(position = "dodge", width = 0.8) +
  labs(
    title = "Rangos de ingresos mensuales",
    x = "Meses en el lugar",
    y = "Número de hogares",
    fill = "Ingreso mensual"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 9),
    legend.text = element_text(size = 8),
    axis.text.x = element_text(angle = 30, hjust = 1)
  )
ggsave("stores/ingresos_meses_bogota.png", g_ingresos, width = 12, height = 6, dpi = 300)

# DIFICULTADES -------------------------------------------------
vars_dificultades <- c(
  "miembros24b_dificultades_nodocu",
  "miembros24b_dificultades_familia",
  "miembros24b_dificultades_discrimina",
  "miembros24b_dificultades_noconocimi",
  "miembros24b_dificultades_noempleo",
  "miembros24b_dificultades_noofertas",
  "miembros24b_dificultades_noexperiencia",
  "miembros24b_dificultades_otra",
  "miembros24b_nosabe",
  "miembros24b_noresponde"
)


dificultades_long <- data_bogota %>%
  select(all_of(vars_dificultades)) %>%
  pivot_longer(cols = everything(),
               names_to = "dificultad",
               values_to = "valor") %>%
  filter(valor == 1)

# Para las dificultades agrupadas
cruce_dificultades <- data_bogota %>%
  select(meses_en_lugar, all_of(vars_dificultades)) %>%
  pivot_longer(cols = -meses_en_lugar,
               names_to = "dificultad",
               values_to = "valor") %>%
  filter(valor == 1) %>%
  count(meses_en_lugar, dificultad, name = "frecuencia") %>%
  pivot_wider(names_from = meses_en_lugar,
              values_from = frecuencia,
              values_fill = 0)

# GRÁFICO 
cruce_dificultades_long <- data_bogota %>%
  select(meses_en_lugar, all_of(vars_dificultades)) %>%
  pivot_longer(cols = -meses_en_lugar,
               names_to = "dificultad",
               values_to = "valor") %>%
  filter(valor == 1) %>%
  count(meses_en_lugar, dificultad, name = "frecuencia") %>%
  mutate(
    dificultad = recode(dificultad,
      "miembros24b_dificultades_nodocu"       = "Falta de documentos",
      "miembros24b_dificultades_familia"      = "Responsabilidades familiares",
      "miembros24b_dificultades_discrimina"   = "Discriminación",
      "miembros24b_dificultades_noconocimi"   = "Falta de conocimiento",
      "miembros24b_dificultades_noempleo"     = "No hay empleo disponible",
      "miembros24b_dificultades_noofertas"    = "No hay ofertas adecuadas",
      "miembros24b_dificultades_noexperiencia"= "Falta de experiencia",
      "miembros24b_dificultades_otra"         = "Otra dificultad",
      "miembros24b_nosabe"                    = "No sabe",
      "miembros24b_noresponde"                = "Prefiere no responder",
      .default = dificultad
    ),
    dificultad = str_wrap(dificultad, width = 25)  # salto de línea automático
  )

g_dificultades <- ggplot(cruce_dificultades_long,
       aes(x = meses_en_lugar, y = frecuencia, fill = dificultad)) +
  geom_col(position = "dodge") +
  labs(
    title = "Dificultades reportadas según tiempo de permanencia",
    x = "Meses en el lugar",
    y = "Número de hogares",
    fill = "Dificultad"
  ) +
  theme_minimal() +
  theme(
    axis.text.x   = element_text(angle = 45, hjust = 1, size = 9),
    legend.position = "bottom",
    legend.title = element_text(size = 8),
    legend.text  = element_text(size = 7)
  ) +
  guides(fill = guide_legend(nrow = 3, byrow = TRUE))
ggsave("stores/dificultades_por_permanencia_bogota.png", g_dificultades, width = 12, height = 7, dpi = 300)

rm(
  vars_mediosvida, vars_24b, vars_principales, vars_dificultades,
  tabla_cruzada_miembros21, tabla_cruzada_miembros30, tabla_cruzada_miembros30b,
  tabla_cruzada_miembros31a, tabla_cruzada_miembros21b,
  dificultades_long, cruce_dificultades, cruce_dificultades_long,
  p1, p2, g_seg_soc, g_ingresos, g_dificultades, necesidades_hacinamiento)
```

# PARTE II.EVIDENCIA EMPIRICA Y ESTIMACIÓN

Para evaluar si el hacinamiento en los hogares representa un factor que incrementa la probabilidad de ocurrencia de diferentes problemas sociales, se empleó una prueba de diferencia de proporciones.

Justificación metodológica: Dado que las variables de interés (acceso_financiero, problemas_viv) son binarias,
las comparaciones entre dos grupos se realizan mediante pruebas de diferencia de proporciones.
Usamos prop.test() (sin corrección de continuidad) para estimar la diferencia y obtener p-valor e IC.


Expectativa teorica:
Teóricamente,en concordancia con la literatura que vincula el hacinamiento con vulnerabilidad socioeconómica, se espera que los hogares en condición de hacinamiento presenten una mayor incidencia de problemas  tales como el acceso financiero, dificultades económicas, entre otros, en comparación con aquellos que no la padecen. De esta forma, se esperaría que en las pruebas de hipótesis siguientes exista una mayor vulnerabilidad reflejada en la proporción para los hogares con hacinamiento critico, en contrate con los de hacinamiento moderado o sin hacinamiento.


## PRUEBA DE HIPÓTESIS: HACIENAMIENO Y PRODUCTOS FINANCIEROS

```{r 1. HACINAMIENTO Y PRODUCTOS FINANCIEROS}
# Lista de columnas de productos financieros válidos
productos_prueba_hip <- c(
  "mediosvida7_mediosvida7_cuenta_ahorro",
  "mediosvida7_mediosvida7_cuenta_corriente",
  "mediosvida7_mediosvida7_cdt",
  "mediosvida7_mediosvida7_billetera_electronica",
  "mediosvida7_mediosvida7_deposito_bajo_monto",
  "mediosvida7_mediosvida7_microcredito",
  "mediosvida7_mediosvida7_prestamo_vivienda",
  "mediosvida7_mediosvida7_prestamo_vehiculo",
  "mediosvida7_mediosvida7_prestamo_de_libre_inversion",
  "mediosvida7_mediosvida7_tarjeta_de_credito",
  "mediosvida7_mediosvida7_otro")

data_prueba_hip_producto <- data_filtrada %>%
  mutate(acceso_financiero =
           if_else(rowSums(select(., all_of(productos_prueba_hip)) == 1, na.rm = TRUE) > 0,
                   1, 0))

# Data set Hacinamiento y Productos Financieros
data_test_prueba_hip_producto <- data_prueba_hip_producto %>%
  filter(hacinamiento %in% c("Sin hacinamiento","Moderado", "Crítico"))

# Comparación variables y  medios de vida
tabla_prueba_hip_producto <- table(
  data_test_prueba_hip_producto$hacinamiento,
  data_test_prueba_hip_producto$acceso_financiero
)
tabla_prueba_hip_producto
prop.table(tabla_prueba_hip_producto, 1)
```
De acuerdo con este primer análisis de las proporciones, se sugiere que el acceso financiero no es completamente lineal en su comportamiento. Dado esto es importante realizar el análisis de diferencia de proporciones para evaluar si estas diferencias observadas son verdaderamente sistemáticamente significativas.

### 1) Prueba Acceso a productos financieros:
Hipótesis formal (Acceso a productos financiero: Sin vs Crítico)
H0: p_Sin >= p_Crítico
H1: p_Sin < p_Crítico
Tipo: prueba unilateral (buscamos demostrar mayor vulnerabilidad en Crítico)
Justificación: la variable 'acceso_financiero' es binaria (0/1), por eso se utiliza
una prueba de diferencia de proporciones entre dos grupos independientes.

Se esperaría que la prueba arroje resultados significativos para rechazar la H0 ya que según la teoría la población sin hacinamiento presenta una mayor estabilidad económica y un entorno habilitación más favorable, lo que se traduce en mejores condiciones de acceso financiero

```{r 1. SIN HACINAMIENTO vs CRÍTICO Y PRODUCTOS FINANCIEROS}
data_test <- data_prueba_hip_producto %>%
  filter(hacinamiento %in% c("Sin hacinamiento", "Crítico")) %>%
  droplevels()
tabla_prueba <- table(data_test$hacinamiento, data_test$acceso_financiero)

x <- tabla_prueba[, "1"]
n <- rowSums(tabla_prueba)

prueba <- prop.test(x, n,
                    alternative = "greater",
                    correct = FALSE)
prueba

```
Dado que el p-valor = 0.2128 es mayor que el nivel de significancia del 5% (α = 0.05), no se rechaza la hipótesis nula.
No existe evidencia estadísticamente significativa para afirmar que los hogares sin hacinamiento tienen mayor acceso a productos financieros que los hogares en hacinamiento crítico. Esto significa que la probabilidad de cometer un error tipo I, es decir rechazar incorrectamente la hipótesis nula cuando en realidad es verdadera,  sería del 21.28%, ya que este porcentaje corresponde al total del área de la distribución de probabilidad que se solapa entre ambas hipótesis.

En esta prueba se evaluó si los hogares sin hacinamiento presentan una mayor probabilidad de acceso a productos financieros respecto a aquellos en hacinamiento crítico. La prueba de diferencia de proporciones sin corrección por continuidad mostró que las proporciones de acceso son 0.530 en hogares sin hacinamiento y 0.455 en hogares con hacinamiento crítico. Sin embargo, esta diferencia no es estadísticamente significativa (χ² = 0.6345; p-valor = 0.2128; IC95%: 
−0.080,1.000).

Por lo tanto, no se rechaza la hipótesis nula, lo cual indica que, con los datos disponibles, no se puede concluir que el hacinamiento crítico reduzca el acceso financiero en comparación con los hogares no hacinados.

```{r 1. GRÁFICA PRUEBA DE HIPÓTESIS SIN HACINAMIENTO VS CRÍTICO Y PRODUCTOS FINANCIEROS}
p_valor <- prueba$p.value
z_obs   <- sqrt(unname(prueba$statistic)) * sign(diff(prueba$estimate))
alpha   <- 0.05
tipo_prueba <- prueba$alternative  # "two.sided", "greater", "less"
media <- 0

# Se definen los valores para realizar el grafico-------------
x <- seq(-4, 4, length.out = 1000)
df <- tibble(
  x = x,
  H0 = dnorm(x, mean = media, sd = 1),
  H1 = dnorm(x, mean = z_obs, sd = 1)
)

# Valores críticos e intervalo según tipo de prueba
if (tipo_prueba == "two.sided") {
  z_crit <- c(qnorm(alpha / 2), qnorm(1 - alpha / 2))
  z_IC   <- c(-1.96, 1.96)
} else if (tipo_prueba == "greater") {
  z_crit <- c(NA, qnorm(1 - alpha))
  z_IC   <- c(media, z_crit[2])
} else {  # "less"
  z_crit <- c(qnorm(alpha), NA)
  z_IC   <- c(z_crit[1], media)
}

z_critico <- ifelse(is.na(z_crit[2]), z_crit[1], z_crit[2])


# Gráfico principal---------------------------------------------
p_z <- ggplot(df, aes(x)) +
  # Curvas de H0 y H1
  geom_line(aes(y = H0, color = "H0: sin efecto (μ = 0)"), size = 1.1) +
  geom_line(aes(y = H1, color = "H1: con efecto observado"), size = 1.1, linetype = "dashed") +

  # Región crítica
  {
    if (tipo_prueba == "two.sided") {
      geom_area(data = df |> filter(x <= z_crit[1]), aes(y = H0), fill = "red", alpha = 0.3) +
      geom_area(data = df |> filter(x >= z_crit[2]), aes(y = H0), fill = "red", alpha = 0.3)
    } else if (tipo_prueba == "greater") {
      geom_area(data = df |> filter(x >= z_crit[2]), aes(y = H0), fill = "red", alpha = 0.3)
    } else {
      geom_area(data = df |> filter(x <= z_crit[1]), aes(y = H0), fill = "red", alpha = 0.3)
    }
  } +

  # Media e intervalo bajo H₀
  geom_vline(xintercept = media, color = "gray40", size = 0.8) +
  geom_vline(xintercept = z_IC, color = "black", linetype = "dotted", size = 0.9) +

  # Marcadores
  geom_point(aes(x = z_obs, y = 0), color = "black", size = 4, shape = 17) +
  geom_point(aes(x = z_critico, y = 0), color = "red", size = 4, shape = 17) +

  # Etiquetas
  annotate("text", x = media, y = 0.42, label = "μ = 0", color = "gray40",
           size = 4.5, fontface = "italic") +
  annotate("text", x = z_obs, y = 0.025,
           label = paste0("Z observado = ", round(z_obs, 3)),
           color = "black", size = 3.3, vjust = -0.5) +
  annotate("text", x = z_critico, y = 0.025,
           label = paste0("Z crítico = ", round(z_critico, 2)),
           color = "red", size = 3.3, vjust = -0.5) +
  annotate("text", x = 0, y = -0.02,
           label = paste0("p-valor = ", round(p_valor, 4)),
           color = "black", size = 3.5, fontface = "italic") +

  # Estilo general
  scale_color_manual(values = c(
    "H0: sin efecto (μ = 0)" = "blue",
    "H1: con efecto observado" = "darkgreen"
  )) +
  coord_cartesian(ylim = c(-0.05, 0.45)) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "top",
        plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 10, hjust = 0.5)) +
  labs(
    title = "Acceso financiero: prueba de comparación (Sin hacinamiento Vs Hacinamiento crítico)",
    subtitle = paste0(" Distribución normal estándar (Z) , Prueba unilateral de diferencia de proporciones (α = ", alpha, ")"),
    x = "Valor Z",
    y = "Densidad",
    color = "Distribución"
  )

p_z

# Guardar en PNG
ggsave("stores/Distribucion_prueba_acceso_financiero.png",plot = p_z, width = 8, height = 5, dpi = 300)

```


** Ahora pasamos a la realización de esta misma prueba con el grupo de hacinamiento moderado y critico
Hipótesis formal (Acceso financiero: Moderado vs Crítico)
H0: p_Moderado >= p_Crítico
H1: p_Moderado < p_Crítico
Tipo: prueba unilateral
Justificación: la variable es binaria; comparamos dos proporciones independientes.

```{r  2. HACINAMIENTO MODERADO VS CRÍTICO Y PRODUCTOS FINANCIEROS}
# Filtrar solo Moderado y Crítico
data_test_MC <- data_prueba_hip_producto %>%
  filter(hacinamiento %in% c("Moderado", "Crítico")) %>%
  droplevels()

# Tabla para la prueba
tabla_MC <- table(data_test_MC$hacinamiento, data_test_MC$acceso_financiero)
tabla_MC

# Valores para la prueba
x_MC <- tabla_MC[, "1"]  # éxitos (con acceso)
n_MC <- rowSums(tabla_MC)  # total por grupo

# Prueba de diferencias de proporciones
prueba_MC <- prop.test(x_MC, n_MC,
                       alternative = "greater", # H₁: Moderado > Crítico
                       correct = FALSE)

prueba_MC

```
La proporción de acceso financiero es significativamente mayor en los hogares con hacinamiento moderado (0.763) comparado con los hogares con hacinamiento crítico (0.455), según la prueba de diferencia de proporciones unilateral (χ² = 8.86; p = 0.00146).
Se rechaza la hipótesis nula, concluyendo que el acceso financiero disminuye de manera estadísticamente significativa cuando el hacinamiento pasa de moderado a crítico.

```{r 2. GRÁFICA PRUEBA DE HIPÓTESIS HACINAMIENTO MODERADO VS CRÍTICO Y PRODUCTOS FINANCIEROS}
p_valor <- prueba_MC$p.value
z_obs   <- sqrt(unname(prueba_MC$statistic)) * sign(diff(prueba_MC$estimate))
alpha   <- 0.05
tipo_prueba <- prueba_MC$alternative  # "two.sided", "greater", "less"
media <- 0

# Se definen los valores para realizar el grafico-------------
x <- seq(-4, 4, length.out = 1000)
df <- tibble(
  x = x,
  H0 = dnorm(x, mean = media, sd = 1),
  H1 = dnorm(x, mean = z_obs, sd = 1)
)

# Valores críticos e intervalo según tipo de prueba
if (tipo_prueba == "two.sided") {
  z_crit <- c(qnorm(alpha / 2), qnorm(1 - alpha / 2))
  z_IC   <- c(-1.96, 1.96)
} else if (tipo_prueba == "greater") {
  z_crit <- c(NA, qnorm(1 - alpha))
  z_IC   <- c(media, z_crit[2])
} else {  # "less"
  z_crit <- c(qnorm(alpha), NA)
  z_IC   <- c(z_crit[1], media)
}

z_critico <- ifelse(is.na(z_crit[2]), z_crit[1], z_crit[2])


# Gráfico principal---------------------------------------------
p_z <- ggplot(df, aes(x)) +
  # Curvas de H0 y H1
  geom_line(aes(y = H0, color = "H0: sin efecto (μ = 0)"), size = 1.1) +
  geom_line(aes(y = H1, color = "H1: con efecto observado"), size = 1.1, linetype = "dashed") +

  # Región crítica
  {
    if (tipo_prueba == "two.sided") {
      geom_area(data = df |> filter(x <= z_crit[1]), aes(y = H0), fill = "red", alpha = 0.3) +
      geom_area(data = df |> filter(x >= z_crit[2]), aes(y = H0), fill = "red", alpha = 0.3)
    } else if (tipo_prueba == "greater") {
      geom_area(data = df |> filter(x >= z_crit[2]), aes(y = H0), fill = "red", alpha = 0.3)
    } else {
      geom_area(data = df |> filter(x <= z_crit[1]), aes(y = H0), fill = "red", alpha = 0.3)
    }
  } +

  # Media e intervalo bajo H₀
  geom_vline(xintercept = media, color = "gray40", size = 0.8) +
  geom_vline(xintercept = z_IC, color = "black", linetype = "dotted", size = 0.9) +

  # Marcadores
  geom_point(aes(x = z_obs, y = 0), color = "black", size = 4, shape = 17) +
  geom_point(aes(x = z_critico, y = 0), color = "red", size = 4, shape = 17) +

  # Etiquetas
  annotate("text", x = media, y = 0.42, label = "μ = 0", color = "gray40",
           size = 4.5, fontface = "italic") +
  annotate("text", x = z_obs, y = 0.025,
           label = paste0("Z observado = ", round(z_obs, 3)),
           color = "black", size = 3.3, vjust = -0.5) +
  annotate("text", x = z_critico, y = 0.025,
           label = paste0("Z crítico = ", round(z_critico, 2)),
           color = "red", size = 3.3, vjust = -0.5) +
  annotate("text", x = 0, y = -0.02,
           label = paste0("p-valor = ", round(p_valor, 4)),
           color = "black", size = 3.5, fontface = "italic") +

  # Estilo general
  scale_color_manual(values = c(
    "H0: sin efecto (μ = 0)" = "blue",
    "H1: con efecto observado" = "darkgreen"
  )) +
  coord_cartesian(ylim = c(-0.05, 0.45)) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "top",
        plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 10, hjust = 0.5)) +
  labs(
    title = "Acceso financiero: prueba de comparación (Hacinamiento moderado Vs Hacinamiento crítico)",
    subtitle = paste0(" Distribución normal estándar (Z) , Prueba unilateral de diferencia de proporciones (α = ", alpha, ")"),
    x = "Valor Z",
    y = "Densidad",
    color = "Distribución"
  )

p_z


# Guardar en PNG
ggsave("stores/Distribucion_prueba_acceso_financiero_2.png",plot = p_z, width = 8, height = 5, dpi = 300)


```

# PRUEBA DE HIPÓTESIS: HACIENAMIENO Y PRODUCTOS FINANCIEROS

```{r Problemas de vivienda}
preg_multi <- c("alojamiento3")

cols_multi <- names(data_filtrada)[str_detect(
  names(data_filtrada),
  paste0("^(", paste(preg_multi, collapse="|"), ")_")
)]
```

```{r Problemas de vivienda}
data_alojamiento3 <- data_filtrada %>%
  pivot_longer(
    cols = all_of(cols_multi),
    names_to = c("pregunta", "respuesta"),
    names_pattern = "([^_]+)_(.*)",
    values_to = "valor"
  ) %>%
  filter(valor == 1)%>%
  mutate(respuesta = str_remove(respuesta, "^alojamiento3_"))
```

```{r Problemas de vivienda}
resumen_aloj3 <- data_alojamiento3 %>%
  count(respuesta, name = "conteo") %>%
  arrange(desc(conteo))
resumen_aloj3
```

```{r Problemas de vivienda}
ggplot(resumen_aloj3, aes(x = reorder(respuesta, -conteo), y = conteo, fill = respuesta)) +
  geom_col() +
  theme_minimal() +
  labs(
    title = "Problemas relacionados con la vivienda y el entorno",
    x = "Tipo de problema reportado",
    y = "Número de hogares"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")

```

```{r Problemas de vivienda}
# Pasar a formato largo (solo respuestas marcadas = 1)
data_aloj3 <- data_filtrada %>%
  pivot_longer(
    cols = all_of(cols_multi),
    names_to = c("pregunta", "respuesta"),
    names_pattern = "([^_]+)_(.*)",
    values_to = "valor"
  ) %>%
  filter(valor == 1)
```

```{r Problemas de vivienda}
resumen_aloj3_menciones <- data_aloj3 %>%
  count(respuesta, name = "conteo") %>%
  arrange(desc(conteo))%>%
  mutate(respuesta = str_remove(respuesta, "^alojamiento3_"))

```

```{r Problemas de vivienda}
resumen_aloj3_hogar <- data_aloj3 %>%
  group_by(respuesta) %>%
  summarise(n_hogares = n_distinct(id_hogar), .groups = "drop")%>%
  mutate(respuesta = str_remove(respuesta, "^alojamiento3_"))

```

```{r Problemas de vivienda}
plot_aloj3_menciones <- ggplot(resumen_aloj3_menciones,
                               aes(x = respuesta, y = conteo, fill = respuesta)) +
  geom_col() +
  labs(title = "Problemas de vivienda (menciones)",
       x = "Problema reportado", y = "Número de menciones") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

plot_aloj3_hogar <- ggplot(resumen_aloj3_hogar,
                           aes(x = respuesta, y = n_hogares, fill = respuesta)) +
  geom_col() +
  labs(title = "Problemas de vivienda (hogares únicos)",
       x = "Problema reportado", y = "Número de hogares") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

# Mostrar juntos
plot_aloj3_menciones + plot_aloj3_hogar

```


```{r Problemas de vivienda}
vars_entorno <- c(
  "alojamiento3_alojamiento3_no_conflic",
  "alojamiento3_alojamiento3_no_higiene",
  "alojamiento3_alojamiento3_no_lnfaestruc",
  "alojamiento3_alojamiento3_no_privacidad",
  "alojamiento3_alojamiento3_desastres",
  "alojamiento3_alojamiento3_ninguna",
  "alojamiento3_alojamiento3_otro"
  )
```

```{r Problemas de vivienda}
resumen_entorno <- data_filtrada %>%
  group_by(hacinamiento) %>%
  summarise(across(all_of(vars_entorno), ~ sum(. == "1", na.rm = TRUE))) 

resumen_entorno
```


```{r Problemas de vivienda}

resumen_aloj3_hacinamiento <- resumen_entorno %>%
  select(hacinamiento, starts_with("alojamiento3")) %>% 
  pivot_longer(
    cols = -hacinamiento,
    names_to = "problema",
    values_to = "conteo"
  ) %>%
  group_by(hacinamiento) %>%
  mutate(
    total = sum(conteo, na.rm = TRUE),
    porcentaje = round((conteo / total) * 100, 1),
    problema = gsub("alojamiento3_alojamiento3_", "", problema)  # limpiar nombres
  ) %>%
  left_join(totales_hogares, by = "hacinamiento") %>%
  mutate(
    porcentaje_hogares = round((conteo / total_hogares) * 100, 1),
    producto = str_remove(problema, "alojamiento3_alojamiento3_")
  )


# --- Gráfico Problemas de vivienda ---
ggplot(resumen_aloj3_hacinamiento, aes(x = problema, y = porcentaje_hogares, fill = hacinamiento)) +
  geom_col(position = "dodge") +
  scale_x_discrete(labels = c(
    "desastres"     = "Desastres",
    "ninguna"       = "Ninguna",
    "no_conflic"    = "Conflicto",
    "no_higiene"    = "No Higiene",
    "no_lnfaestruc" = "No Infraestructura",
    "no_privacidad" = "No Privacidad",
    "otro"          = "Otros"
  )) +
  labs(
    title = "Problemas relacionados con la vivienda y el entorno",
    x = "Problema reportado",
    y = "% de hogares"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```


```{r Problemas de vivienda}
problemas_cols <- c(
  "alojamiento3_alojamiento3_desastres",
  "alojamiento3_alojamiento3_no_conflic",
  "alojamiento3_alojamiento3_no_higiene",
  "alojamiento3_alojamiento3_no_lnfaestruc",
  "alojamiento3_alojamiento3_no_privacidad",
  "alojamiento3_alojamiento3_otro"
)

data_probs <- data_filtrada %>%
  mutate(problemas_viv =
           if_else(rowSums(select(., all_of(problemas_cols)) == 1, na.rm = TRUE) > 0,
                   1, 0)
  )
```


```{r Problemas de vivienda}
# Tabla para la prueba Sin hacinamiento vs Crítico
tabla_probs_SC <- table(
  data_probs$hacinamiento,
  data_probs$problemas_viv
)

tabla_probs_SC
prop.table(tabla_probs_SC, 1)
```




## 2) Prueba de problemas de vivienda
Hipótesis formal (Problemas vivienda: Sin vs Crítico)
H0: p_Crítico <= p_Sin
H1: p_Crítico > p_Sin
Tipo: prueba unilateral (se espera mayor incidencia de problemas en hogares críticos)
Justificación: 'problemas_viv' es binaria (0/1); se compara proporción entre grupos.

```{r Problemas de vivienda}
# Filtrar solo Sin y Crítico
data_test_SC <- data_probs %>%
  filter(hacinamiento %in% c("Sin hacinamiento", "Crítico")) %>%
  droplevels()

# Tabla
tabla_SC <- table(data_test_SC$hacinamiento, data_test_SC$problemas_viv)
tabla_SC

# Éxitos y totales
x_SC <- tabla_SC[, "1"]
n_SC <- rowSums(tabla_SC)

# Prueba unilateral: Crítico > Sin hacinamiento
prueba_SC <- prop.test(x_SC, n_SC,
                       alternative = "less",
                       correct = FALSE)

prueba_SC
```
La proporción de hogares que reporta al menos un problema de vivienda o entorno es significativamente mayor en los hogares con hacinamiento crítico (51.5%), en comparación con los hogares sin hacinamiento (23.2%).
La prueba estadística unilateral para diferencia de proporciones indica que esta diferencia es estadísticamente significativa (χ² = 10.97; p = 0.00046), por lo que se rechaza la hipótesis nula.Dado que el p-valor es muy inferior al nivel de significancia del 5% (α = 0.05), la probabilidad de incurrir en un error tipo I, es menor al 0.05%, lo que otorga un alto nivel de confianza en el resultado obtenido ya que las areas de la distribución que se cruzan son minimas.
Esto confirma que, a mayor severidad del hacinamiento, se intensifican las dificultades asociadas al entorno y las condiciones de habitabilidad del hogar.

```{r Grafico prueba 3}

p_valor <- prueba_SC$p.value
z_obs   <- sqrt(unname(prueba_SC$statistic)) * sign(diff(prueba_SC$estimate))
alpha   <- 0.05
tipo_prueba <- prueba_SC$alternative  # "less"
media <- 0

# ============================================================
# Curvas teóricas de H₀ y H₁
# ============================================================
x <- seq(-4, 4, length.out = 1000)
df <- tibble(
  x = x,
  H0 = dnorm(x, mean = media, sd = 1),
  H1 = dnorm(x, mean = z_obs, sd = 1)
)

# ============================================================
# Valores críticos e intervalo según tipo de prueba
# ============================================================
if (tipo_prueba == "two.sided") {
  z_crit <- c(qnorm(alpha / 2), qnorm(1 - alpha / 2))
  z_IC   <- c(-1.96, 1.96)
} else if (tipo_prueba == "greater") {
  z_crit <- c(NA, qnorm(1 - alpha))
  z_IC   <- c(media, z_crit[2])
} else {  # "less"
  z_crit <- c(qnorm(alpha), NA)
  z_IC   <- c(z_crit[1], media)
}

z_critico <- ifelse(is.na(z_crit[2]), z_crit[1], z_crit[2])

# ============================================================
# GRAFICAR DISTRIBUCIONES H₀ Y H₁
# ============================================================
p_SC <- ggplot(df, aes(x)) +
  # Curvas de H0 y H1
  geom_line(aes(y = H0, color = "H0: sin efecto (μ = 0)"), size = 1.1) +
  geom_line(aes(y = H1, color = "H1: con efecto observado"), size = 1.1, linetype = "dashed") +

  # Región crítica
  geom_area(data = df |> filter(x <= z_crit[1]), aes(y = H0), fill = "red", alpha = 0.3) +

  # Media e intervalo bajo H₀
  geom_vline(xintercept = media, color = "gray40", size = 0.8) +
  geom_vline(xintercept = z_IC, color = "black", linetype = "dotted", size = 0.9) +

  # Marcadores
  geom_point(aes(x = z_obs, y = 0), color = "black", size = 4, shape = 17) +
  geom_point(aes(x = z_critico, y = 0), color = "red", size = 4, shape = 17) +

  # Etiquetas
  annotate("text", x = media, y = 0.42, label = "μ = 0", color = "gray40",
           size = 4.5, fontface = "italic") +
  annotate("text", x = z_obs, y = 0.025,
           label = paste0("Z observado = ", round(z_obs, 3)),
           color = "black", size = 3.3, vjust = -0.5) +
  annotate("text", x = z_critico, y = 0.025,
           label = paste0("Z crítico = ", round(z_critico, 2)),
           color = "red", size = 3.3, vjust = -0.5) +
  annotate("text", x = 0, y = -0.02,
           label = paste0("p-valor = ", round(p_valor, 4)),
           color = "black", size = 3.5, fontface = "italic") +

  # Estilo general
  scale_color_manual(values = c(
    "H0: sin efecto (μ = 0)" = "blue",
    "H1: con efecto observado" = "darkgreen"
  )) +
  coord_cartesian(ylim = c(-0.05, 0.45)) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "top",
        plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 10, hjust = 0.5)) +
  labs(
    title = "Problemas en Vivienda: prueba de comparación (Sin hacinamiento Vs Hacinamiento crítico)",
    subtitle = paste0(" Distribución normal estándar (Z) , Prueba unilateral de diferencia de proporciones (α = ", alpha, ")"),
    x = "Valor Z",
    y = "Densidad",
    color = "Distribución"
  )

p_SC


# Guardar en PNG
ggsave("stores/Distribucion_prueba_problemas_vivienda.png",plot = p_SC, width = 8, height = 5, dpi = 300)


```


Ahora pasamos a la realizacion de esta misma prueba con el grupo de hacinamiento moderado y critico
Hipótesis formal (Problemas vivienda: Moderado vs Crítico)
H0: p_Crítico <= p_Moderado
H1: p_Crítico > p_Moderado
Tipo: prueba unilateral
Justificación: variable binaria; comparamos proporciones entre dos grupos independientes.

```{r Problemas de vivienda}
data_test_viv <- data_probs %>%
  filter(hacinamiento %in% c("Moderado", "Crítico")) %>%
  droplevels()

tabla_viv <- table(data_test_viv$hacinamiento, data_test_viv$problemas_viv)
tabla_viv

x_viv <- tabla_viv[, "1"]
n_viv <- rowSums(tabla_viv)

prueba_viv <- prop.test(
  x_viv, n_viv,
  alternative = "greater", # Crítico > Moderado
  correct = FALSE
)

prueba_viv
```
Aunque el porcentaje de hogares que reporta al menos un problema relacionado con la vivienda o el entorno es mayor entre aquellos con hacinamiento crítico (51,5%) respecto a los de hacinamiento moderado (44,1%), la diferencia no es estadísticamente significativa (p = 0,754).
Esto sugiere que, en esta muestra, las condiciones físicas y ambientales de la vivienda y el entorno no difieren sustancialmente entre niveles de hacinamiento moderado y crítico.

```{r Grafico prueba 4}

p_valor <- prueba_viv$p.value
z_obs   <- sqrt(unname(prueba_viv$statistic)) * sign(diff(prueba_viv$estimate))
alpha   <- 0.05
tipo_prueba <- prueba_viv$alternative  # "less"
media <- 0

# ============================================================
# Curvas teóricas de H₀ y H₁
# ============================================================
x <- seq(-4, 4, length.out = 1000)
df <- tibble(
  x = x,
  H0 = dnorm(x, mean = media, sd = 1),
  H1 = dnorm(x, mean = z_obs, sd = 1)
)

# ============================================================
# Valores críticos e intervalo según tipo de prueba
# ============================================================
if (tipo_prueba == "two.sided") {
  z_crit <- c(qnorm(alpha / 2), qnorm(1 - alpha / 2))
  z_IC   <- c(-1.96, 1.96)
} else if (tipo_prueba == "greater") {
  z_crit <- c(NA, qnorm(1 - alpha))
  z_IC   <- c(media, z_crit[2])
} else {  # "less"
  z_crit <- c(qnorm(alpha), NA)
  z_IC   <- c(z_crit[1], media)
}

z_critico <- ifelse(is.na(z_crit[2]), z_crit[1], z_crit[2])

# ============================================================
# GRAFICAR DISTRIBUCIONES H₀ Y H₁
# ============================================================
p_SC <- ggplot(df, aes(x)) +
  # Curvas de H0 y H1
  geom_line(aes(y = H0, color = "H0: sin efecto (μ = 0)"), size = 1.1) +
  geom_line(aes(y = H1, color = "H1: con efecto observado"), size = 1.1, linetype = "dashed") +

  # Región crítica
  geom_area(data = df |> filter(x <= z_crit[1]), aes(y = H0), fill = "red", alpha = 0.3) +

  # Media e intervalo bajo H₀
  geom_vline(xintercept = media, color = "gray40", size = 0.8) +
  geom_vline(xintercept = z_IC, color = "black", linetype = "dotted", size = 0.9) +

  # Marcadores
  geom_point(aes(x = z_obs, y = 0), color = "black", size = 4, shape = 17) +
  geom_point(aes(x = z_critico, y = 0), color = "red", size = 4, shape = 17) +

  # Etiquetas
  annotate("text", x = media, y = 0.42, label = "μ = 0", color = "gray40",
           size = 4.5, fontface = "italic") +
  annotate("text", x = z_obs, y = 0.025,
           label = paste0("Z observado = ", round(z_obs, 3)),
           color = "black", size = 3.3, vjust = -0.5) +
  annotate("text", x = z_critico, y = 0.025,
           label = paste0("Z crítico = ", round(z_critico, 2)),
           color = "red", size = 3.3, vjust = -0.5) +
  annotate("text", x = 0, y = -0.02,
           label = paste0("p-valor = ", round(p_valor, 4)),
           color = "black", size = 3.5, fontface = "italic") +

  # Estilo general
  scale_color_manual(values = c(
    "H0: sin efecto (μ = 0)" = "blue",
    "H1: con efecto observado" = "darkgreen"
  )) +
  coord_cartesian(ylim = c(-0.05, 0.45)) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "top",
        plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 10, hjust = 0.5)) +
  labs(
    title = "Problemas en Vivienda: prueba de comparación (Hacinamiento moderado Vs Hacinamiento crítico)",
    subtitle = paste0(" Distribución normal estándar (Z) , Prueba unilateral de diferencia de proporciones (α = ", alpha, ")"),
    x = "Valor Z",
    y = "Densidad",
    color = "Distribución"
  )

p_SC


# Guardar en PNG
ggsave("stores/Distribucion_prueba_problemas_vivienda_2.png",plot = p_SC, width = 8, height = 5, dpi = 300)
```


# PRUEBA DE HIPÓTESIS: HACIENAMIENTO Y GASTO EN VIVIENDA

## Prueba de gasto en vivienda
 Justificación metodológica (gasto en vivienda):
 'pct_vivienda' es una variable cuantitativa continua.
 Se verifica normalidad por grupo con Shapiro-Wilk y homogeneidad de varianzas.
 Si al menos un grupo no cumple normalidad, se utiliza Kruskal-Wallis (no paramétrica).
```{r Gasto en vivienda}
#Test Shapiro
by(data_filtrada$pct_vivienda, data_filtrada$hacinamiento, shapiro.test)
```
Continuamos con un Kruskal–Wallis (no paramétrico)
```{r Gasto en vivienda}
#Prueba global
kruskal.test(pct_vivienda ~ hacinamiento, data = data_filtrada)
```

```{r Gasto en vivienda}
#Prueba global
pairwise.wilcox.test(
  data_filtrada$pct_vivienda,
  data_filtrada$hacinamiento,
  p.adjust.method = "bonferroni"
)
```

Al evaluar el porcentaje del gasto total del hogar destinado a vivienda según el nivel de hacinamiento, se aplicó la prueba de Kruskal–Wallis debido al incumplimiento del supuesto de normalidad. El resultado no mostró diferencias globales estadísticamente significativas (χ² = 5.81, p = 0.0547).En términos del riesgo de error tipo I, este valor indica que la probabilidad de rechazar la hipótesis nula siendo verdadera es del 5.47%, ligeramente superior al nivel de significancia establecido (α = 0.05), por lo que no se rechaza la hipótesis nula.
Sin embargo, las comparaciones por pares indicaron que los hogares con hacinamiento moderado destinan un porcentaje significativamente menor de su gasto total a vivienda en comparación con los hogares sin hacinamiento (p = 0.045).
No se encontraron diferencias significativas entre los hogares en hacinamiento crítico y los demás niveles. Esto sugiere que la relación entre gasto en vivienda y hacinamiento no es estrictamente lineal, pues los hogares con hacinamiento moderado pueden estar expuestos a mayores presiones económicas en otras necesidades básicas.


Conclusión general (Parte 2 — Contrastes)
 - Se encontraron diferencias estadísticamente significativas en:
   * Acceso financiero: Moderado > Crítico (p = 0.00146)
   * Problemas vivienda: Crítico > Sin hacinamiento (p = 0.00046)
 - En el análisis del % de gasto en vivienda, la prueba global Kruskal-Wallis fue marginal
   (p = 0.0547); en comparaciones por pares, sólo Sin vs Moderado resultó significativo (p = 0.045).
 Interpretación: el hacinamiento está asociado a distintas dimensiones de vulnerabilidad;
 la política pública debería priorizar acciones sobre vivienda y acceso financiero para hogares críticos,
 y programas de apoyo socio económico para hogares moderados cuya vulnerabilidad está menos visible.



